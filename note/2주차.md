---

typora-root-url: ./
---

# Day6.자바기초

### Test076.java
```java
/*	package  -import - class 선언식으로
	javac -d . Test065.java
	java -classpath . temp.Test076
	import 의 단위는 클래스다
	import 는 언제하냐? 다른클래스 가져다 쓸 때
	왜 try catch 안 쓰면 에러가 나나? 
	 :throws XXXException 형태로 선언된 함수는 XXXException이 깐깐한 경우(컴파일시 에러)에 해당 예외를 처리할 수 있는 try catch 영역 안에서 사용해야 한다.
*/
package temp;
import java.io.OutputStream;//다른 패키지의 클래스르 사용하기 위해서는 import 해야 함, import는 클래스 단위로 함
import java.io.FileOutputStream;// import 의 단위는 클래스 단위로 함
import java.io.FileNotFoundException;

public class Test076 {
    public static void main( String[] args){
        try{
            OutputStream out = new FileOutputStream("a.dat");
        }
        catch( FileNotFoundException e ){ // 얘도 클래스다 => import

        }
    }
}

```



```java

import java.io.OutputStream;//자기가 속한 패키지에 없는 것은 import 해야 함

public class Test076 {
    public static void main( String[] args){
        OutputStream out = null;

    }
}

#commit 1.

/*	package  -import - class 선언식으로
	javac -d . Test065.java
	java -classpath . temp.Test076
*/
package temp;
import java.io.OutputStream;//자기가 속한 패키지에 없는 것은 import 해야 함

public class Test076 {
    public static void main( String[] args){
        OutputStream out = null;

    }
}

commit 2.

/*	package  -import - class 선언식으로
	javac -d . Test065.java
	java -classpath . temp.Test076
	import 의 단위는 클래스다
	import 는 언제하냐? 다른클래스 가져다 쓸 때
	왜 try catch 안 쓰면 에러가 나나?
	 :throws XXXException 형태로 선언된 함수는 XXXException이 깐깐한 경우에 해당 예외를 처리할 수 있는 try catch 영역 안에서 사용해야 한다.
*/
package temp;
import java.io.OutputStream;//다른 패키지의 클래스르 사용하기 위해서는 import 해야 함, import는 클래스 단위로 함
import java.io.FileOutputStream;// import 의 단위는 클래스 단위로 함
import java.io.FileNotFoundException;

public class Test076 {
    public static void main( String[] args){
        try{
            OutputStream out = new FileOutputStream("a.dat");
        }
        catch( FileNotFoundException e ){ // 얘도 클래스다 => import

        }
    }
}

commit 3.

/*	package  -import - class 선언식으로
	javac -d . Test065.java
	java -classpath . temp.Test076
	import 의 단위는 클래스다
	import 는 언제하냐? 다른클래스 가져다 쓸 때
	왜 try catch 안 쓰면 에러가 나나?
	 :throws XXXException 형태로 선언된 함수는 XXXException이 깐깐한 경우에 해당 예외를 처리할 수 있는 try catch 영역 안에서 사용해야 한다.
	 
	 FileNotFoundException 을 IOException으로 고쳐도 될까
	 -돤다고 함 이유 IOException 이 조상클래스라서
*/
package temp;
import java.io.IOException;
import java.io.OutputStream;//다른 패키지의 클래스르 사용하기 위해서는 import 해야 함, import는 클래스 단위로 함
import java.io.FileOutputStream;// import 의 단위는 클래스 단위로 함

public class Test076 {
    public static void main( String[] args){
        try{
            OutputStream out = new FileOutputStream("a.dat");
        }
        catch( IOException e ){ // 얘도 클래스다 => import

        }
    }
}

commit 4.

/*	package  -import - class 선언식으로
	javac -d . Test065.java
	java -classpath . temp.Test076
	import 의 단위는 클래스다
	import 는 언제하냐? 다른클래스 가져다 쓸 때
	왜 try catch 안 쓰면 에러가 나나?
	 :throws XXXException 형태로 선언된 함수는 XXXException이 깐깐한 경우에 해당 예외를 처리할 수 있는 try catch 영역 안에서 사용해야 한다.

	 FileNotFoundException 을 IOException으로 고쳐도 될까
	 -돤다고 함 이유 IOException 이 조상클래스라서
	 
	 commit 5
	 1.에러는 발생시에 잡아주면 에러 발생 안된걸로 한다.(일사부재리)
	 2.에러가 발생할 수 있으면 그 사실을 명시하면 된다.
	 (아래 경우는 생성자 호출한 쪽이 아니라 main 을 호출한 쪽이 처리한다.
	 사원이 사고치는데 대리는 그책임을 부장에게 넘기고 부장이 처리한다.)
*/
package temp;
import java.io.IOException;
import java.io.OutputStream;//다른 패키지의 클래스르 사용하기 위해서는 import 해야 함, import는 클래스 단위로 함
import java.io.FileOutputStream;// import 의 단위는 클래스 단위로 함

public class Test076 {
    public static void main( String[] args) throws  IOException{ //명시하면 에러 x main을 호출한 쪽에서 책임을 짐
            OutputStream out = new FileOutputStream("a.dat");
            //발생된 에러를 잡으면 프로그램이 죽지 않는다.


    }
}

commit . 5

```






### Test077.java

```java

package temp;

import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;


public class Test077 {
    public static void main(String[] args) {
        try{
	
		OutputStream out = new FileOutputStream("a.dat");
		}
		catch( FileNotFoundException e ){
		
		}
		}
}
/*
    Tet076복습하기
 */
```

#### -2
```java
package temp;

import java.io.IOException;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;


public class Test077 {
    public static void main(String[] args) throws IOException {// 메인을 호출한 쪽에서 책임을 지게 하는데 JVM 은 죽는 걸로 책임짐
            OutputStream out = new FileOutputStream("a.dat");

    }
}
/*
    Tet076복습하기
 */

```

#### -3

```java
package temp;

import java.io.IOException;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;


public class Test077 {
    public static void main(String[] args) throws IOException {// 메인을 호출한 쪽에서 책임을 지게 하는데 JVM 은 죽는 걸로 책임짐 부장이 책임짐
           try {
               OutputStream out = new FileOutputStream("a.dat");

           }catch (IOException e)//대리가 혼내고 끝이어야하는데
           {
               throw e; //다시 던지기 때문에 대리가 사표를 내면서 부장으로 올라감
           }

    }
}
/*
    Tet076복습하기
 */

```



### Test078.java

```java
package temp;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class Test078 {
    public static void main(String[] args) throws IOException {
        OutputStream out = new FileOutputStream("a.dat");
        out.write( 65 );
        out.write( 66 );
        out.write( 67 );
        out.close();
    }
}

/*
    FileOutputStream : 파일에 저장하는 방법을 제공한다.
    OutputStream : 내보내는 방법을 추상화 한 클래스
    ( 이걸 상속받은 클래스는 , 이걸로 가리킬 수 있고 , 이것에 선언된거만 쓴다.

    write : 한번에 1 바이트를 내보내는데 , 오버라이딩 도니 write 가 호출된다.
        (api 보니까) , 오버라이딩 된 write 는 매개변수의 값을
        a.dat 파일에 저장하게 된다.

    out.close(); - 내보내는 통로를 닫고 , 뒤처리를 해 준다,

    AppleOutputStream  extends OutputStream ...
    형태로 선언되어졌다고 셈 치면 , 인스턴스만 바꾸면 나머지는  바꿀 필요업다.
 */

```



### Test079.java

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

/*
    in.read() 는 오버라이딩 된 코드일까?아니면 InputSteam 에서 선언된걸까?
    -코드를 읽는 눈이 있어야 한다.

    in.read() : 한 바이트씩 읽어들이는 역할
    더 이상 읽을 것이 없을 떼 -1이 나온다.

    Stream (input/ output )개념
    -byte 단위로 전송한다.
    -순서대로 읽고 순서대로 내보낸다.
    -중간부분만 따로 읽고 내보내는 건 없다. 무조건 처음부터 끝까지!
    -다 썻으면 반드시 close 는 호출해 주어야 한다.
 */
public class Test079 {
    public static void main(String[] args) throws IOException {
        InputStream in = new FileInputStream("a.dat");
        int a = in.read();
        int b = in.read();
        int c = in.read();
        int d = in.read();

        in.close();

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);

    }
}

```





### Test081.java

```java
import java.io.*; //공부할 때 귀찮으면 이렇게

public class Test081 {
    public static void main(String[] args) throws IOException {
        InputStream in = new FileInputStream("a.dat");
        OutputStream out = new FileOutputStream("b.dat");

        //엄청 많이 씀 : 외우시오
        int r = 0;
        while (( r = in.read(buf) ) != -1){
            out.write( r );
        }

        out.close();
        in.close();
    }
}

```



```java
import java.io.*; //공부할 때 귀찮으면 이렇게

public class Test081 {
    public static void main(String[] args) throws IOException {
        InputStream in = new FileInputStream("C:\\A\\jdk-6u30-apidocs.zip");
        OutputStream out = new FileOutputStream("C:\\A\\b.zip");

        //엄청 많이 씀 : 외우시오
        int r = 0;
        byte[] buf = new byte[1024*8];

        while (( r = in.read(buf) ) != -1){
            out.write( buf, 0, r );
        }

        out.close();
        in.close();
    }
}

```

a.exe			buf				b.exe

[1]				[1]				[1]

[2]				[2]				[2]

[3]

[4]

[5]				r

​				[2]	길이

버퍼링: 한꺼번에 읽고 내보낸다.

int read(byte[] buf) : buf가 감당가능한 만큼 읽고 , 읽은 데이터 갯수 리턴

void write (byte[] buf, int s , int r) : buf의 내용을 내보낸다. s부터 r 만큼





### Test082.java SImple Client

```java
import java.io.IOException;
import java.net.Socket;
public class Test082 {
    public static void main(String[] args) throws IOException {
        Socket skt = new Socket("192.168.2.73",1123);
        skt.close();
    }
}

```

찾아가는 역할

### Test083S.java Simple Server

```java
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class Test083S {
    public static void main(String[] args) throws IOException {
        ServerSocket svr = new ServerSocket(1123);
        System.out.println("Before accept");
        Socket skt =svr.accept();
        System.out.println("After accept");

        skt.close();

        svr.close();
    }
}

```

대기 1123은 포트임. 포트는 정수(음수는 안됨)이다.



### Test084.java

```java
import java.io.*;

public class Test084 {
    public static void main(String[] args) throws IOException {
        long start =System.currentTimeMillis();
        /*
            IGreet ig = new SharpDeco(new HelloGreet());
            ig.greet();    => #Hello#
            -이전에 배웠던 데코레이터 패턴 예제

            out.write(..) 호출했을때 대상은 FileOutoutStream 에서 지정한다.
                BufferedOutoutStream 에서 버퍼링을 제공한다.
            -두 클래스가 결합한 결과를 만드는데 사용자는 OutputStream 에서
            지정한 함수만 사용하면 된다.

            :아 두개는 실제로 같은 설계기법으로 구현된 코드이다.
            java의 io패키지는 전부 데코레이터 패턴으로 만들어졌다.
         */
        InputStream in = new BufferedInputStream(new FileInputStream("C:\\A\\VSCodeUserSetup-x64-1.36.1.exe"));
        OutputStream out = new BufferedOutputStream(new FileOutputStream("c.dat"));
        int r=0;
        while ((r =in.read())!=-1){
            out.write(r);
        }

        in.close();
        out.close();
        long end =System.currentTimeMillis();
        System.out.println(end- start);
    }
}
/*
    java.io 패키지가 데코레이터 패턴이라는 설계기법으로 구현되었다.
    -HellloGreet MerciGreet StarDeco SharpDeco : 데코레이터 패턴의 예제

    1바이트씩 복사하는 코드를 짜세요
    BufferedInputStream 은 데코레이터 패턴으로 버퍼를 이용해 빠르게 해준다.
*/
```



### Test085.java

```java
import java.io.*;

public class Test085 {
    public static void main(String[] args) throws IOException {
        /*
        데코레이터 패턴으로 이해하면 out 이 가리키는 대상은
            FileOutputStram(d.dat)에 저장화되
            ObjectOutputStream 에서 제옹하는 방법을 사용하게 된다.

            ObjectOutputStream 은 writeInt writeDouble writeUF 등을 wprhd
            -얀깨진다.

         */
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("d.dat")); //코딩용글씨 쓰면 좋은점 길이가 다른 것으로 오타 찾을 수 있음
        out.writeInt(10101);
        out.writeUTF("오늘 저녁 뭐를 먹나?");
        out.writeInt(10102);
        out.writeInt(10103);
        out.close();

        ObjectInputStream in = new ObjectInputStream(new FileInputStream("d.dat"));
        int a = in.readInt();
        String e = in.readUTF();
        int b = in.readInt();
        int c = in.readInt();
        in.close();

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(e);

    }
}
/*
        OutputStream out = new FileOutputStream("d.dat"); //코딩용글씨 쓰면 좋은점 길이가 다른 것으로 오타 찾을 수 있음
        out.write(10101);
        out.write(10102);
        out.write(10103);
        out.close();

        InputStream in = new FileInputStream("d.dat");
        int a = in.read();
        int b = in.read();
        int c = in.read();
        int d = in.read();
        in.close();

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
 */
```



### Test086.java Reader Writer

```java
package chat;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.Reader;
import java.io.Writer;

/*
    OutputStreadm InputStream : 전송단위 byte : 바이너리 파일전송용
    Reader Writer : 전송단위 char :문자로 된 데이터 전송용

    char 는 2바이트고, 유니코드를 지원한다.
    유니코드는 모든 글자를 다 포용하지 못한다. (6만자 제한)
    -웬만한 글자는 포용한다. 한글 + 영문 + 중국어 + 아랍어 + 일본어 ...

    황장가능한 가변길이를 가지는 문자체제를 도입 : UTF-8(웹 표준)
    
 */
public class Test086 {
    public static void main(String[] args) throws Exception{
        Writer out =  new FileWriter("a.txt");
        out.write('한');
        out.write('뷁');
        out.write('д');
        out.write('林');
        out.write('あ');
        out.close();

        Reader in =new FileReader("a.txt");
        System.out.println( (char)in.read());
        System.out.println( (char)in.read());
        System.out.println( (char)in.read());
        System.out.println( (char)in.read());
        System.out.println( (char)in.read());
        in.close();

        //글자 하나를 넣고 뺄때


    }
}

```



### Test087 Output stream

```java
import java.io.*;

/*
=   OutputStreamWriter InputStreamReader 는 char 입출력을
        byte 입출력으로 전환해 줍니다.
    ( 220 qhfxmfmf 110 볼트로 바꾸듯 2byte 입출력을 1byte 로 바꿔준다.)
 */
public class Test087 {
    public static void main(String[] args) throws Exception{
        Writer out =  new OutputStreamWriter(new  FileOutputStream ("a.txt"));
        out.write('한');
        out.write('뷁');
        out.write('д');
        out.write('林');
        out.write('あ');
        out.close();

        Reader in =new InputStreamReader( new FileInputStream("a.txt"));
        System.out.println( (char)in.read());
        System.out.println( (char)in.read());
        System.out.println( (char)in.read());
        System.out.println( (char)in.read());
        System.out.println( (char)in.read());
        in.close();

        //글자 하나를 넣고 뺄때


    }
}

```



### flush()

버퍼는 언제 비워지냐 1.꽉 찬 경우

​									2. flush()를 한 경우

즉 버퍼를 쓴 경우 flush() 를 해주자

close가 되면 자동으로 flush()를 해줌





# Day7 DataBase

---

오라클 10

mysql56





## DataBase수업

#### show databases;

+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sakila             |
| test               |
| world              |
+--------------------+
6 rows in set (0.00 sec)

-먼저 database 만들고 , 그 안에 테이블을 만든다.



#### 데이터베이스 생성

create database study;

Query OK, 1 row affected (0.00 sec)



#### 데이터베이스 사용

use study;

Database changed



#### 테이블생성

create table study01t (

id INT not null ,

score TINYINT not null

);

Query OK, 0 rows affected (0.03 sec)

대소문자 상관없음.



#### 드랍테이블

drop table study01t;



####  삽입

insert into study01t values( 10101, 100 );

insert into study01t values( 10102, 90 );



#### 셀렉트

select * from study01t;

int		Tinyint  크기차이

+-------+-------+
| id    | score |
+-------+-------+
| 10101 |   100 |
| 10102 |    90 |
+-------+-------+

세로 필드 컬럼(도메인값에 맞는 데이터만 올 수 있음)

insert into study01t values( 10103, 80 );

-입력시 순서를 바꾸어서 입력할 수 있다.

insert into study01t ( score , id ) values( 90 , 10104);



#### 테이블 개념

​	int												Tinyint  크기차이

| id    | score |
| ----- | ----- |
| 10101 | 100   |
| 10102 | 90    |

세로 필드 컬럼(도메인값에 맞는 데이터만 올 수 있음)



테이블에 있어야 하는 개념

1.필드 (Field ) -컬럼

--자료형을 저장한다. (int , tinyint)

--같은 자료형의 , 같은 의미의 값이 와야한다.

2.레코드(Record) -ROW

--입력의 단위

--데이터들이 연관되어진 묶음이어야 한다.

--"이 두가지 개념이 있어야 테이블이라 할 수 있다."

#### 삭제

delete from study01t where id=10101;

--where 조건을 만족하는 레코드를 없앤다.

delete from study01t where id<10104;

--조건에 맞는 것 전부 삭제

delete from study01t;

--조건을 주지 않으면 전부 삭제

--하고치면 주석으로 취급

delete from study01t where 0=1;

--where가 false이므로  아무것도 삭제하지 않으나

delete from study01t where 1=1;

--경우 where가 항상 트루라서 모든 레코드가 만족하게 되어 전부 삭제됨

#### 데이터크기

--tinyint 1바이트

--int 4바이트

#### 수정

update study01t set score = 110 where id=10101;

​								동작			|  조건 필터

update study01t set score = score-10 where id=10101;

--*기존의값을 활용해서 만들 수 있다.

update study01t set score = id -10000 where id=10101;

--*같은 레코드의 데이터를 활용

update study01t set score = score-10 where id!=10101; 

-- 

update study01t set id = 0, score = 0 where id=10101;

--2개 한번에 바꾸기

--where문장은 delete, update , select 와 연동.

#### select

select * from study01t where id = 10101;

select * from study01t where id != 10101;



select id from study01t where id != 10101;

--특정 필드만 보여줄때

select score, id from study01t where id != 10101;  

--실수로 score 뒤에 , 찍지 않으면 id값만 나옴

select score+5, id from study01t where id != 10101;

--select 는 데이터를 가공해서 보여줄 수 있다.

select score+5 as sungjuk, id from study01t where id != 10101;

-- 컬럼명을 바꾸어서 출력이 가능하다.

(보여지는 것만 바꾸었다. 이름 바뀐 거 아님)

SELECT score , score as sungjk from study01t;

-- 하나의 컬럼을 여러번 출력해도 무방하다. 



### 연습1

create table study02t ( 

id char(5) not null,

 name varchar(10) null

);

insert into study02t values('a0001', 'abcd'); 

insert into study02t values('a0001', 'HelloworldXXX');
--ERROR 1406 (22001): Data too long for column 'name' at row 1
insert into study02t values('a0001', 'Helloworld');
--Query OK, 1 row affected (0.00 sec)

insert into study02t values('a01', 'apple');
--Query OK, 1 row affected (0.00 sec)

select id,name from study02t;

select concat(id, '*')from study02t;
+-----------------+
| concat(id, '*') |
+-----------------+
| a0001*          |
| a0001*          |
| a01*            |
+-----------------+

oracle : 'a01    * 이렇게 나옴

--문자열 : ' '로 감싼다. 작은따옴표 이용 char  or   varchar 자료형

--char : 고정길이 문자열 (학번 주민번호 ...) 

--char 는 무조건 고정길이

'a01' 을 넣어도 무조건 5자리 차지(낭비각오)

varchar 은 가변길이

'apple' 을 넣으면 5자리만 공간사용. 낭비 적다.

varchar char 는 최대길이 넘겨서 넣을 수 없다.

......

#### 셀렉트이용 검색

select * from studentT where addr ='역삼동';

select *from studentT where addr Like '역%';

select *from studentT where addr Like '%산동';

'역%' :역으로 시작하는 것

'%삼동' : 삼동으로 끝나는 ...

select *from studentT where addr Like '%포%';

포 들어가는 것

mysql> select *from studentT where addr Like '%포_';

_는 한글자 %은 0개수이상 글자 아무거나

--부분 문자열 추출이 가능하다.

select substr( addr , 1 , 2 ) from studentT;

select * from studentT where substr( addr , 1 , 2 )  = '역삼';

select length( addr ) from studentT;

--유니코드 2바이트 유니코드는  한글을 다 집어넣을 수 없다.

--글자길이 utf-8 3바이트 잡혀있어서 3씩 3글자라서 

* 중요한 거 aggregate functions : 5가지

  min max count avg sum   (암기요망)

  "유일한 결과를 출력하는 성격이 있다."

select *from scoret where subid = 'KOR1';

select min(score) from scoret where subid = 'KOR1';

select sum(score) from scoret where subid = 'KOR1';

select avg(score) from scoret where stid = '10101';

select count(score) from scoret where subid = 'KOR1'; 

select max(score) from scoret where subid = 'KOR1';

국어에서 70점 이하 점수 받은 사람은?

select * from scoret where score<=70 and subid = 'KOR1';

수학에서 60, 80 점 받은 학생은?

select * from scoret where subid = 'MAT1' and (score = 60 or score = 80);

select * from scoret where subid = 'MAT1' and score in (60,80);

리눅스는 mysql 대소문자 가림 윈도우는 아님

--결과 레코드의 갯수를 count(*) 로 알 수 있다.

select count(*) from scoret where subid = 'MAT1' and score in (60,80);

 

studentT ,subjectt , scoret 는 얽혀 있다.

'여러 개의 테이블이 연관관계를 가지고 데이터베이스를 구성'

Q. 역삼동 학생들의 국어 성적은 ?

select * from studentT where addr Like '%역삼%';

 select * from scoret where subid = 'KOR1' and stid IN ('10101','10103');

두번으로 하여 찾을 순 있다.

select * from scoret where subid = 'KOR1' and stid IN (select stid from studentT where addr Like '%역삼%');

여러개 나오는 결과를 이용할 때는 IN 또는 NOT IN을 사용한다. 서브쿼리-하나의 쿼리의 결과를 이용해서 다른 쿼리를 돌릴 수 있다. 이것을 '서브쿼리'라고 한다.

Q. 국어에서 평균 이하의 점수를 받은 학생은 누구?

평균select avg(score) from scoret where subid ='KOR1' =68.3333

select stid from scoret where score<68.3333;

select stid from scoret where score<(select avg(score) from scoret where subid ='KOR1') and subid='KOR1';

select name from studentT where stid in(select stid from scoret where score<(select avg(score) from scoret where subid ='KOR1') and subid='KOR1');

유일한 서브쿼리 결과와 비교는 = != < <= > >=을 쓴다.

서브쿼리는 반드시 괄호로 묶어 주어야한다.



Q김씨성 가진 학생들의 수학평균은 ?

select stid from studentT where name Like '김%';

select avg(score) from scoret where stid in (10105 , 10106) and subid = 'MAT1';

select avg(score) from scoret where stid in (select stid from studentT where name Like '김%')and subid ='MAT1';



Q.영어에서 70 점 이하의 점수를 받은 학생들의 성적을 -5 점 하라.

update scoret set score=score-5 where subid = 'ENG1' and score<=70;

update scoret set score=score-5 where subid = 'ENG1' and stid in(select stid from scoret where subid = 'ENG1' and score<= 70);

MySQL 은 Oracle 과는 달리 UPDATE 나 DELETE 시 자기 테이블의 데이타를 바로 사용 못하므로 아래와 같은 SQL 을 실행시 1093 에러가 발생함.

update scoret set score=score-5 where subid = 'ENG1' and stid in(select * from (select stid from scoret where subid = 'ENG1' and score<= 70)as X);

이렇게하면 가능

서브쿼리는 성능이 좋지 않다고 함.

"AGGREGATE FUNCTION 은 GROUP BY , HAVING 과 연동된다."

select avg(score) from scoret group by stid;

select avg(score) from scoret where stid = 10101;

--stid 에 동일한 값을 가진 레코드를 짜매어서 평균낸 결과.



--group by 를 썼을 때는 group by에 지정된 컬럼만select 절에 와야 한다.

select stid, avg(score) from scoret group by stid;



select stid, avg(score) from scoret where avg(score)<75 group by stid;

왜 안되나 ? where 는 통계처리에 우선한다.

해서 having 은 통계처리 이후에 동작한다.

select stid, avg(score) from scoret group by stid having avg(score) <=75;

#### "서브쿼리는 크게 3종휴료 나뉜다."

1. where절의 서브쿼리 

2. from 절의 서브쿼리( inline view)

3. select 절의 서브쿼리 (엄청난 결과/ 엄청난 부담)"

    

from 절의 서브쿼리 : select  결과를 마치 table 처럼 보면 된다.

select stid, round(avg(score),2)as xx from scoret group by stid;

--될 것 같은데 이게 안되나 ( from 절 서브쿼리는 데이터베이스마다 지원 안하기도 하다)

select * from (select stid, round(avg(score), 2) as avg from scoret group by stid) xx where avg <= 75;

안됨

 create view score2v as select stid, round(avg(score), 2 ) as xx from scoret group by stid;

select * from score2v;

--view 는 실제로 데이터가 존재하는 테이블이 아니라

​			테이블 데이터를 이용해서 만들어진 하나의 결과화면일 뿐이다.

--view 를 대상으로 수정 삭제는 무의미하다.

select stid , name from studentt;

select stid , name, (select avg(score) from scoret )as avg from studentT;

--레코드 하나마다  서브쿼리 문장도 돌아가야 한다.

select stid , name, (select avg(score) from scoret where stid = '10101' )as avg from studentT;

--원래는 테이블명. 컬럼명 식으로  쓰는게 맞았다 (우리는 생략)

select studentT.stid, studentT.name from studentT;

--studentT가 길기 때문에 x로 바꾸어서 쓴다. 

select x.stid, x.name from studentT as x;

--stid = x.stid 의 형태로 select 절의 필드값을 서브쿼리에서 사용할 수 있다.

select x.stid , x.name, (select avg(score) from scoret  where stid = x.stid )as avg from studentT as x;

--select 결과를 마치 테이블처럼 쓴다. from 절의 서브쿼리 

inline view 

select x.stid, x.avg from(select stid, avg(score) as avg from scoret group by stid ) as x;

create table temp01t as select stid , avg(score) as avg from scoret group by stid;

create view temp01v as select stid , avg(score) as avg from scoret group by stid;

--오버헤드 있음 , 생성 이후의 데이터 변경까지도 반영된다.

select * from temp01v;

--속도빠름 , 생성 이후의 데이터는 반영안된다.

select * from temp01t;

update scoret set score = 100 where stid = '10101';

 select * from temp01t;



#### --등수 구하자.

1.   select x.stid , x.avg from temp01t as x;

2.   select x.stid , x.avg, ( select count(*)+1 from temp01t where avg> x.avg)as rank from temp01t as x;

   이 경우 한번 불러올 때마다 레코드 수 +1 만약 3000명학생이 순위를 보면 900만번 실해하게된다.

3. create table temp02t as  select x.stid , x.avg, ( select count(*)+1 from temp01t where avg> x.avg)as rank from temp01t as x;

   그래서 이렇게 임시 테이블을 만들면 대략 3000번만 돌아가게 된다. 서브쿼리가 실행되지 않음

   오버헤드를 줄일 수 있다.  

select * from temp02t order by rank; 오름차순 정렬

select * from temp02t order by rank desc; 내림차순 정렬

-- 임시테이블과 뷰는 흩어진 데이터에서 자신이 원하는데이터로 가공할 수 있는 방법을 제공한다.

​	( 비정형 데이터에서 정형화 된 데이터를 만들어 낸다.)

-- 뷰는 오버헤드가 있지만 데이터의 변경을 즉각 반영한다.

​	임시테이블은 오버헤드가 적지만 데이터의 변경을 즉각 반영 못함.

-- select 서브 쿼리는 오버헤드가 크다.

​	(  1000명의 등수를 처리한 결과를 1000명이 동시 열람하면 

​		100만건의  쿼리가 동작하는 셈 + group by 오버헤드 포함)

-- 임시테이블은 이러한 부담을 극적으로 줄여준다.

​	(도사들은 이걸 기가 막히게 잘 쓴다.)

--mysql 은 일련번호  auto_increment primary key 사용

(oracle 은 sequence 를 이용한다.)

--now() 는 현재시간 . 그것을 입력할 때 datatime 자료형울 쓴다.

create table study3t ( 
	no int not null auto_increment primary key,
    theTime datetime not null
    );

insert into study3t values (default , now());

#### --datetime 자료형에 들어있는 값은 연산이 가능하다. 

select no, date_add(theTime, INTERVAL 1 MONTH) from study3t;

select no, date_add(theTime, INTERVAL 10 DAY) from study3t;

select no, date_add(theTime, INTERVAL 4 HOUR) from study3t;

-- 날짜 데이터를 다룰 때 연산의 필요성이 없으면 char 쓴다.



--연산은 불가능하나 오버헤드가 작다.

create table study4t ( 
	no int not null auto_increment primary key,
    theTime char(19) not null
    );

 insert into study4t values (default , now());



# Day8. DataBase

---

프로젝트 기간이 짧은 경우 중요한 것 빼곤 전부 쳐낸다.

데이터베이스 설계 프로세스

1. 업무분석

   명사, 동사에 주의하여 업무를 정확하게 기술한다.

   업무 파악에 도움이 되는어떤형태의 자료도 확보한다.

   가능한한 UI 를 그려가면서 인터뷰를 진행한다.

   ( 나중에 갈아엎더라도

   이 때 그려진 UI는 설계에 결정적인 영향을 끼친다.)

   말 만들기에 따라서 설계에 영향이 갈 수 있다. 경험이 중요하다.

   

2. 엔티티( Entity ) 도출

   추상명사 중에서 pk로 구분되어지는 것이 Entity 가 된다.

   PK 는 단일 필드의 특징이 있어야 한다.

   (주민번호의 경우 두개의 필드로 볼 수 있지만

   단일한 성격으로 파악하는 것이 바람직하다. )

   기록될 만한 가치가 있는 정보인지 판별해야 한다.

   

   PK ? Primary Key  기본키

   :레코드를 구분하는 기준으로 사용하는 

   

3. 

4. 

5. 



외래키

성적테이블에 stid , subid - 성적 테이블의 stid 는 학생테이블에 쓰이는 의미를 가져다가 쓴다.

(성적테이블의 stid 의 10101 은 학생테이블 stid 의 10101 과 동일한 의미이다.)



### Mysql

select *from score2t;

| 10101 | 홍길동 | 역삼동 | 60   | 80   | 90   |
| ----- | ------ | ------ | ---- | ---- | ---- |
| 10102 | 고길동 | 개포동 | 90   | 90   | 100  |
| 10103 | 이기자 | 역삼동 | 70   | 90   | 70   |
| 10104 | 박기자 | 한남동 | 80   | 70   | 70   |
| 10105 | 김영삼 | 홍제동 | 50   | 60   | 80   |
| 10106 | 김대중 | 한남동 | 60   | 80   | 60   |

select stid ,  name, (kor1 + eng1 + mat1 ) /3 as avg from score2t;

| 10101 | 홍길동 | 76.6667 |
| ----- | ------ | ------- |
| 10102 | 고길동 | 93.3333 |
| 10103 | 이기자 | 76.6667 |
| 10104 | 박기자 | 73.3333 |
| 10105 | 김영삼 | 63.3333 |
| 10106 | 김대중 | 66.6667 |

score2t 는 과목이 늘거나 줄 때에 대책이 심각하다.

그러나 동작속도는 무지하게 빠르다 (위의 평균 구함)

score2t 와 같이 설계된 경우를 비정규화 ... 라고 한다.

정규화: Less Column (테이블당 필드의 갯수가 적다 5~12개)

more Table (score2t가 한개로 되는 걸 우리는 3개를 만들었다...)

필드와 데이터의 중복저장을 허용 안한다.(비디오점의 대여여부)



비정규화 : More Column , Less Table

필드와 데이터의 중복저장을 허용한다.(속도때문에)

"대부분 정규화를 기본으로 해서 적절한 비정규화를  도입한다."

...

#### --테이블 껍데기만 만드는 것

create table student_xt as select stid, name addr from score2t where 0 = 1 ;



#### --테이블에 select 결과를 입력하는 것

insert into student_xt select stid, name addr from score2t where 1= 1 ;





create table score_xt as select stid , 'KOR1' as subid, kor1 as score from score2t where 0=1;

insert into score_xt select stid , 'kor1' , kor1 from score2t where 1=1;



비정규화 된 설계에서 정규화 된 설계로 옮길 수도 있고

정규화 된 설계에서 비정규화 된 설계로 옮길 수 있어야 한다.

...

JOIN (서브쿼리와 유사한데 , 서브쿼리와 좀 달라요)

![0725쓰레드 정리](.\img\0725쓰레드 정리.jpg)



studentt : stid (pk)<- scoret : stid (FK)

대부분의  JOIN 은 PK - FK 사이에서 일어난다.

SELECT * FROM studentt INNER JOIN scoret ON studentt.stid = scoret.stid;

select * from studentt, scoret where studentt.stid = scoret.stid;(오라클)

INNER JOIN : PK - FK 데이터가 일치하는 레코드를 짜매준다.

SELECT name , addr FROM studentt INNER JOIN  scoret ON studentt.stid = scoret.stid WHERE subid= 'MAT1';

--JOIN 을 이용하면 흩어진 데이터를 통합해서 보여지게 할 수 있다.

  (서브쿼리도 가능 . 헌데 성능이 틀리다.

​	해서 같은 결과를 만들되 성능이 향샹되게 만드는 것이 SQL 튜닝의             	영역)

Q.subjectt 과 scoret 를 inner join 해서 

​	10101 국어  90 ...의 형태로 출력하세요.

select stid, name, score from subjectt INNER JOIN scoret ON subjectt.subid = scoret.subid;



-- subid 는 짜매어 주면 두번 나타난다. 해서 출처를 명시해 준다.



select stid, name, score,subjectt.subid from subjectt,  INNER JOIN scoret ON subjectt.subid = scoret.subid;

--subjectt 를 x ,scoret 를 y 로 각각 줄여서 쓰면 이렇게 가능

select stid, name, score,x.subid  from subjectt. as x, INNER JOIN scoret as y ON x.subid = scoret.subid;



SELECT stid, avg(score) as avg FROM scoret group by stid;

SELECT * FROM (

SELECT stid, avg(score) as avg FROM scoret group by stid) AS x;

SELECT * FROM (SELECT stid, avg(score) as avg FROM scoret group by stid) AS x INNER JOIN studentt AS y ON y.stid = x.stid;

SELECT y.stid, name , avg  FROM (SELECT stid, avg(score) as avg FROM scoret group by stid) AS x INNER JOIN studentt AS y ON y.stid = x.stid;



--OUTER JOIN ( 외부조인 )

INSERT INTO subjectt values ('PHY1','물리');

SELECT * FROM subjectt INNER JOIN scoret

ON subjectt.subid = scoret.subid;



물리가 추가되었어도 한건의 성적데이터가 없은 짜매어줄 대상이 없다.

회원가입이 되어도 글 쓴게 없으면 조인 걸어도 나타나지 않는다.

이런 식으로 한 쪽 테이블에서만 보여지고 짜매지지 않는 경우라도

한건 보이지게 만드는 형태의 조인이 OUTER JOIN 이다.



SELECT * FROM subjectt LEFT OUTER JOIN scoret ON subjectt.subid =scoret.subid;

 :부족함(NULL로 채움)이 나타나는 반대편을 명시한다. (LEFT)

SELECT * FROM scoret   RIGHT OUTER JOIN subjectt ON subjectt.subid =scoret.subid;



-- 아래는 과목별로 수강 데이터의 갯수를 센다.

​    count(*) 는 레코드의 갯수를 세고 , 

​	count(필드) 는 해당 필드의 null 이 아닌 데이터의 갯수를 센다.

SELECT subjectt.subid , count(*) FROM subjectt LEFT OUTER JOIN scoret ON subjectt. subid = scoret.subid GROUP BY subjectt.subid;

+-------+----------+
| subid | count(*) |
+-------+----------+
| ENG1  |        6 |
| KOR1  |        6 |
| MAT1  |        6 |
| PHY1  |        1 |
+-------+----------+

이 된다.



SELECT subjectt.subid , count(score) FROM subjectt LEFT OUTER JOIN scoret ON subjectt. subid = scoret.subid GROUP BY subjectt.subid;

::  CONSTRAINT - 물리적인 제약조건을 필드(들) 에 걸어준다.

SCORE :  0~100 사이의 값만 허용한다 한다.

desc 테이블명; : 테이블 타입정보

insert into scoret values ('10101', 'PHY1' ,120);



#### ALTER TABLE scoret ADD CONSTRAINT CHECK_scoret_score  CHECK (score>= 0 AND score <=100);  <-이거 되게해보자

ALTER TABLE (테이블 수정 ) ADD CONSTRAINT ( 제약조건 추가 )

제약조건은 CHECK , UNIQUE , PRIMARY KEY , FOREIGN KEY 4가지를 주로 쓴다.

지울 때는 

ALTER TABLE scoret DROP CONSTRAINT CHECK_scoret_score;

CHECK CONSTRAINT 는 WHERE 절의 조건을 이용하여 제약을 걸 수 있다.

( IN, NOT IN, = != ...을 사용할 수 있다.)

....

--NOT NULL, NO DUPLICATE 를 물리적으로 보장한다.

ALTER TABLE subjectt ADD CONSTRAINT PK_subject_subid PRIMARY KEY (subid);

INSERT INTO subjectt VALUES ('KOR1', '국어');

#### ALTER TABLE scoret ADD CONSTRAINT FK_scoret_subid FOREIGN KEY(subid) REFERENCES subjectt (subid);



 INSERT INTO scoret VALUES ('10101' , 'XXXX' , 50); <-에러뜸
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`study`.`scoret`, CONSTRAINT `FK_scoret_subid` FOREIGN KEY (`subId`) REFERENCES `subjectt` (`subId`))

이유 참조무결성

INSERT INTO scoret VALUES ('10101' , 'PHY1' , 50); 됨 PHY1이 있기 때문에

### -- 참조무결성 : PK 쪽에서 쓰여진 데이터만 FK 쪽에 쓰여질 수 있다.

​	-회원가입 해야 글 쓴다.

​	-회원등록해야 예약한다.

​    -등록된 아이템만 대여가능하다 ....



UNIQUE CONSTRAINT : NULL 허용하는데 중복은 안된다.

( 테이블 분리할 때 절묘하게 쓴다. )

다대다로 만들로 - > UNIQUE -> 일대다로 동작 

create table study5t (
     id int not null
     );

ALTER TABLE study5t ADD CONSTRAINT UQ_study5t_id UNIQUE( id );

--중복입력이 허용되지 않는다.

insert into study5t values (100);



--일대다 상황에서 테이블 분리하는 방법

1. 일단 다대다로 생각하고 테이블을 생성한다.

2. PK 중 하나에 UNIQUE CONSTRAINT 를 건다.

   : 다대다가 일대다로 바뀐다

   : PK를 어T 지울 떄 (오라클과 약간 다르다)

#### ALTER TABLE study5t DROP INDEX UQ_study5t_id;

 검색하면서 삭제하자.....





#### Day9. 

"고객은 메뉴를 주문한다"

"고객은 주문을 일으킨다"

![0725고객은_주문을_일으킨다](D:\doc\메모\자바캠프\img\0725고객은_주문을_일으킨다.jpg)



중국집에 경우 

곱배기가 있기 때문에

pk를 

| 메뉴(pk) | 사이즈(pk) |
| -------- | ---------- |
| 자장면   | L          |
| 자장면   | M          |



이렇게 복합키로 하면 좋다.



### 쓰레드

![0725쓰레드](.\img\0725쓰레드.jpg)

베이커리 알고리즘

하나의 cpu를 이용 시분할해서 나눠처리



Test093.java

```java
package filedown;

class CustomThreaded implements Runnable{

    //오버라이딩 할 때 throws Exception 같은 거 붙여서는 못한다.
    // (조상에 선언된 대로만 재 정의해야 한다.

    @Override
    public void run(){
        for (int i = 0; i < 100; i++) {
            System.out.println("HellowWorld " + i);
        }
    }
}

public class Test093 {
    public static void main(String[] args) {
        //자바가 서버를 만드는데 적합하다. 이유 1. 소켓이 잘 되어 있고 2. 쓰레드가 잘 되어있다. 이 둘다 bulit in 되어있다.
        Runnable rb = new CustomThreaded();
        rb.run(); //단순 함수 호출
/*
        // new Thread() 하면 가상의 CPU 를 OS에서 할당받는다. (분신)
//       할당 받은 cpu 는 생성자에 넘겨진 포인터를 물고간다.
//       start() 호춠에 준비과정을 거쳐 새로운 가상 CPU 가
//                rb.run() 을 호출한다.
        1. Runnable 상속받은 클래스 선언 .
        2. new Thread 하면서 1의 인스턴스의 포인터를 넘긴다.
        3.Thread :: start() 를 호출하면 가상 CPU (Thread) 가 run() 호출
        다른방법이 있긴하다.
        */
        Thread th = new Thread( rb );
        th.start();
    }
}

```

![0725 쓰레드실행](/img/0725 쓰레드실행.png)



### Test094.java Thread

```java
package filedown;

/*
    Program : executable file.
    Process : a running program.       프로그램 더블클릭실행하면 프로세스
    Thread : a light-weighted process   (독자 행동을 하지만 조금 다르다.
    :쓰레드는 프로세스 안에서만 존재가 가능하다.
    :쓰레드간 메모리를 공유할 수 있다.
        프로세스간은 메모리 전달은 가능해도 공유는 불가능하다.
       '프로세스간의 메모리 전달의 대표적 수단이 소켓이다.'
       ( 복사 &붙이기도 전달로 볼 수 있지만 이건 윈도우에서 국한된 개념)
       :프로세스 종료 == 프로세스가 가진 모든 쓰레드의 종료
       (인간을 생각하면 이해 쉬움 : 뇌 위장 척추 ... )
  */
class A implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("Apple!");
        try {
            int time = (int) (Math.random() * 1000);
            Thread.sleep(time); // 밀리세컨드 단위
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        }
    }
}

class B implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("Banana!");
            try {
                int time = (int) (Math.random()*1000);
                Thread.sleep( time); // 밀리세컨드 단위  throw가 있기 때문에 catch 나 throws 해줘야
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Test94 {
    public static void main(String[] args) {
        new Thread( new A()).start();
        new Thread( new B()).start();
    }
}
/* 쓰레드는 독자적으로 돌아가는 프로그램이 된다.
    :apple 사이에 banana 끼어들게 안 짰는데 결과는 그러했다.
    어떻게 해석할까?
 */

```

![0725 카피앤페이스트](/img/0725 카피앤페이스트.png)



### Test095.java

```java
package filedown;

class Toilet {

    public void bigWork(String str) {
        System.out.println("step 1:" + str + " do big work");
        System.out.println("step 2:" + str + " do big work");
        System.out.println("step 3:" + str + " do big work");
        System.out.println("step 4:" + str + " do big work");
        System.out.println("step 5:" + str + " do big work");
    }
}

class A2 implements Runnable {

    public A2(Toilet toilet) {
        this.toilet = toilet;
    }

    private Toilet toilet = null;

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            toilet.bigWork("Apple");
            int time = (int) (Math.random() * 1000);
            try {
                Thread.sleep(time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class B2 implements Runnable {

    private Toilet toilet = null;

    public B2(Toilet toilet) {
        this.toilet = toilet;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            toilet.bigWork("banana");
            int time = (int) (Math.random() * 1000);
            try {
                Thread.sleep(time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Test095 {

    public static void main(String[] args) {
        Toilet t = new Toilet();

        new Thread(new A2(t)).start();
        new Thread(new B2(t)).start();

    }
}
/*
    STEP 1.APPLE
    STEP 2.APPLE
    STEP 1.BANANA
    STEP 3.APPLE
    STEP 2.BANANA
    STEP 4.APPLE
    STEP 3.BANANA
    STEP 5.APPLE
    STEP 4.BANANA
    STEP 5.BANANA
    ... 하나밖에 없는 화장실에서 대 참사가 일어나는 중 ...
    쓰레드는 독자적으로 돌아가는 프로그램이기에 이런 일은 얼마든지 가능하다.

    화장실 문에 잠금을 해 줘야 한다.

    쓰레드가 프로그램에서는 잠금이 중요한데 그것을 동기화(Sychronization) 이라고 한다.

 */
```

쓰레드들이 같은 곳을 접근하면



### Test096.java

```java
package filedown;
/*
    모든 인스턴스에는 lock 이라는 개념의 자물쇠? 열쇠? 가 있다.
    synchronized (this){...}

    this가 가리키는 인스턴스가 가지고 있는 록을 획득해야 { 에 진입 가능.
    획득하지 못하면 쓰레드는 머추어 기다려야 한다.
 */
class Toilet2 {

    public void bigWork(String str) {
        synchronized ( this){
        System.out.println("step 1:" + str + " do big work");
        System.out.println("step 2:" + str + " do big work");
        System.out.println("step 3:" + str + " do big work");
        System.out.println("step 4:" + str + " do big work");
        System.out.println("step 5:" + str + " do big work");

        }
    }
}

class A3 implements Runnable {

    public A3(Toilet toilet) {
        this.toilet = toilet;
    }

    private Toilet toilet = null;

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            toilet.bigWork("Apple");
            int time = (int) (Math.random() * 1000);
            try {
                Thread.sleep(time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class B3 implements Runnable {

    private Toilet toilet = null;

    public B3(Toilet toilet) {
        this.toilet = toilet;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            toilet.bigWork("banana");
            int time = (int) (Math.random() * 1000);
            try {
                Thread.sleep(time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Test096 {

    public static void main(String[] args) {
        Toilet t = new Toilet();

        new Thread(new A2(t)).start();
        new Thread(new B2(t)).start();

    }
}

```

메모리 텅텅비는데 성능이 안나온다. synchronized 의심한번.



### Test097.java 

```java
package filedown;

/*
    모든 인스턴스에는 lock 이라는 개념의 자물쇠? 열쇠? 가 있다.
    synchronized (this){...}

    this가 가리키는 인스턴스가 가지고 있는 록을 획득해야 { 에 진입 가능.
    획득하지 못하면 쓰레드는 머추어 기다려야 한다.
 */
class Toilet3 {

    public void bigWork(String str) {
        synchronized (this) {
            System.out.println("step 1:" + str + " do big work");
            System.out.println("step 2:" + str + " do big work");
            System.out.println("step 3:" + str + " do big work");
            System.out.println("step 4:" + str + " do big work");
            System.out.println("step 5:" + str + " do big work");

        }
    }
    //중간에 방해받으면 안된다. 메서드에도 넣을 수 있음
    //필요한 부분에만 걸어야한다 아니면 퍼포먼스 낮아짐
    public synchronized void sleepWork(String by) {
        System.out.println("SLEEP STEP 1. " + by);
        System.out.println("SLEEP STEP 2. " + by);
        System.out.println("SLEEP STEP 3. " + by);
    }
}

class A4 implements Runnable {

    public A4(Toilet3 toilet) {
        this.toilet = toilet;
    }

    private Toilet3 toilet = null;

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {

            int time = (int) (Math.random() * 1000);
            if(time % 2 == 0){
                toilet.bigWork("Apple");

            }else {
                toilet.sleepWork("Apple");
            }

            try {
                Thread.sleep(time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class B4 implements Runnable {

    private Toilet3 toilet = null;

    public B4(Toilet3 toilet) {
        this.toilet = toilet;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            int time = (int) (Math.random() * 1000);
            if(time % 2 == 0){
                toilet.bigWork("Apple");

            }else {
                toilet.sleepWork("Apple");
            }
            try {
                Thread.sleep(time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Test097 {

    public static void main(String[] args) {
        Toilet3 t = new Toilet3();

        new Thread(new A4(t)).start();
        new Thread(new B4(t)).start();

    }
}
/*


 */
```

![0725 쓰레드메모리공유](/img/0725 쓰레드메모리공유.png)



### Test098.java

```java
package filedown;

class A5 implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("A ruuning");
        }
    }
}

class B5 implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("B ruuning");
        }
    }
}


class C5 implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("C ruuning");
        }
    }
}

public class Test098 {
    public static void main(String[] args) {
        Thread[] threads = new Thread[3];
        threads[0] = new Thread(new A5());
        threads[1] = new Thread(new B5());
        threads[2] = new Thread(new C5());
        threads[0].start();
        threads[1].start();
        threads[2].start();

        try {
            threads[0].join();
            threads[1].join();
            threads[2].join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("최종정리");
    }
}



```



### Test099.java

```java
package filedown;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class Test099 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver"); //클래스를 이름으로 찾아 로딩시키는 것 이 떄 staticInitializer가 호출
        /*
            connection 은 mysql 에 소켓으로 접속하는 것과 관계 깊음
            study : 데이터베이스 명
            root / 1111 계정과 암호

            127.0.0.1 : 로컬호스트 네트워크 카드 밖으로 나가지 않고 나에게 접속할 때 랜카드없어도 됨
         */
        Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306?serverTimezone=UTC/study","root","1111");
        System.out.println(conn.toString());
        conn.close();
    }
}
// C:\JavaWork\mysql-connector-java-5.0.8-bin.jar
// jar 파일은 클래스 파일을 압축해서 배포하는 파일
// java -classpath .;mysql-connector-java-5.0.8-bin.jar Test099

/*
    -classpath 매번 안 잡아줘도  되는 방법
    C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext
 */
```

### Test099_2.java


```java
package filedown;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class Test099_2 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/study?characterEncoding=UTF-8&serverTimezone=UTC", "root", "1111");
        /*
            Statement 는 conn 줄을 타고 오가는 바구니를 연상하면 된ㄴ다.

            excuteUpdate 함수의 리턴값은 변경된 레코드의 갯수이다.
            select 는 레코드를 변경하지 않는다.
            해서 executeUpdate 는 insert / delete / update 문장에 사용한다.

            conn.close() 신중하개 해야 한다. (줄 끊는거다)
            stmt.close() 도 신중하게 ( 바구니 내리는 거 )

            conn 형성 - stmt 형성 - 작업 - stmt.close() - conn.close()
            이 순서를 지켜서 작업한다.
         */

        Statement stmt = conn.createStatement();
        System.out.println(stmt);
        String sql = "insert into studentt values('10107', '또오치', '쌍문동')";
        String sql2 = "delete from studentt where name = '또오치'";
        String sql3 = "update studentt set addr = '이도동' where stid='10101'";
        int rc = stmt.executeUpdate(sql2);  //리턴 변경한 레코드 수 excuteUpdate는 select문에 사용하지 않는다.
        System.out.println(rc);
        stmt.close();
        conn.close();
    }
}


//}
//public class Test099_2 {
//    public static void main(String[] args) throws ClassNotFoundException, SQLException {
//        Class.forName("com.mysql.jdbc.Driver"); //클래스를 이름으로 찾아 로딩시키는 것 이 떄 staticInitializer가 호출
//
//        Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306?serverTimezone=UTC/study","root","1111");
//        Statement stmt = conn.createStatement();
//        String sql = "insert into studentt values ('10107' , '또오치 ', '쌍문동')";
//        String sql2 = "delete from studentt where stid = '10107'";
//        String sql3 = "update studentt set addr = '이도동' where stid ='10101'";
//        System.out.println(stmt);
//        stmt.close();
//        conn.close();
//    }
//}


```



### Test099_3.java

```java
package filedown;

import java.sql.*;

public class Test099_3 {
    static {
        //클래스가 로딩되는 시점에 호출
        /*
            Connection , Statement 모두 인터페이스이다.
            DriverMAnager.getConnecion 안에서는 Connection 을 상속받은
                모종의 클래스의 인스턴스를 리턴한다.
                그것은 Mysql 에 접속할 수 있는 기능을 구현하고 있다.

            그 모종의 클래스를 세팅하는 코드가
            Class.forName("com.mysql.jdbc.Driver");         */
        System.out.println("클래스로딩");
    }
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/study?characterEncoding=UTF-8&serverTimezone=UTC", "root", "1111"); //Connection 인터페잇
        System.out.println(conn.getClass().getName());

        Statement stmt = conn.createStatement();  //Statement 인터페이스

        /*
            ResultSet 은 CURSOR ( select 결과 ) 에 접근 가능한 정보
            CURSOR 는 서버에 생긴다.

            Connection 이 닫힌 다음에서는 ResultSet 은 사용 불가하다.
            ( Connection 닫기 전에 사용 끝나야 한다.)

            Connection 은 대단히 비싼자원이고 제한적이다.
            접속후에 빨리 끊어주는 게 바람직하다. (콜센터를 연상하면 된다.)

         */
        String sql = "select * from studentt";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()){
            String stid = rs.getString("stid");
            String name = rs.getString("name");
            String addr = rs.getString("addr");

            System.out.println(stid + "\t" +name +"\t" +addr);
        }
        rs.close();
        stmt.close();
        conn.close();
    }
}
/*resultSet은 서버 사이드 커서 커서는 전진은 가능하나 후진불가

 */

```

![0725connection과statement](/img/0725connection과statement.jpg)



### Test099_4.java

```java
package filedown;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/*
    property 는 멤버변수를 이야기함
    헌데 멤버변수는 getter/ setter 를 이용하고 private 하게 선언
 */
class StudentVO {
    private String stId = null;
    private String name = null;
    private String addr = null;

    public String getStId() {
        return stId;
    }

    public void setStId(String stId) {
        this.stId = stId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddr() {
        return addr;
    }

    public void setAddr(String addr) {
        this.addr = addr;
    }
}

public class Test099_4 {
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/study?characterEncoding=UTF-8&serverTimezone=UTC", "root", "1111"); //Connection 인터페잇
        System.out.println(conn.getClass().getName());

        Statement stmt = conn.createStatement();  //Statement 인터페이스

        /* O-R Mapping 규칙 (Golden Rule, Rule Of Thumb)
            field -> property
            table -> class
            record - > instance

            왜 ArrayList 가 적당할까?
            -계속 쌓기만 하므로 array List가 빠르다.

            Connection 은 살아있을 때 할 거 다해야한다.
            Connection 은 빨리 끊어야한다.
            이 두가지 조건을 아래 코드는 이상적으롷 구현하고 있다.

            Vo : ValueObject 의 약자 - 값을 담는 객체
            -테이블 구조와 동일하게 , 레코드 하나를 인스턴스에 담을 수 있는 역할

            DTO Data Tranfer Object
            Entity 등을 사용하는 경우도 있는데 실은 다 같은 얘기

         */
        List<StudentVO> rl = new ArrayList<StudentVO>();

        String sql = "select * from studentt";
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) {
            StudentVO vo = new StudentVO();
            vo.setStId(rs.getString("stid"));
            vo.setName(rs.getString("name"));
            vo.setAddr(rs.getString("addr"));
            rl.add(vo);
        }
        // -------------------------------------------------------------------------
        //conn.close() 이후에도 List 안에는 결과가 담겨 있다.
        for (StudentVO vo : rl) {
            System.out.println(vo.getStId() + "\t" + vo.getName() + "\t" + vo.getAddr());
        }
        rs.close();
        stmt.close();
        conn.close();
    }
}


```



### Test100.java

```java
package filedown;

import java.sql.*;

/*
    클라우드에서 ojdbc14.jar 파일다운 : 작업폴더에 복사

    Mysql 의 코드와 거의 틀린 점이 없다.
    Connection , Statement 를 상속한 Oracle 과 연동 가능한 클래스를
        OracleDriver에서 DriverMAanager 에  세팅해주면
        Oracle 에 맞추어 개발된 , Connecion Statement ResultSet 등을
        상속받은 클래스가 공급되는 구죄앋.
 */
public class Test100 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        Class.forName("oracle.jdbc.driver.OracleDriver");
        Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521/XE","HR","HR");
        System.out.println( conn.getClass().getName());
        Statement stmt = conn.createStatement();

        // 현재시간 - mysql 은 now() , oracle 은 sysdate
        String sql = "Select SYSDATE FROM DUAL";
        ResultSet rs = stmt.executeQuery(sql);
        //결과가 1개인 경우 while 보단 if가 더 좋음
        if (rs.next()){
            //필드명 대신에 숫자 가능 1은  나열된 첫번째 필드를 의미
            String l = rs.getString(1);
            System.out.println(l);
        }
        rs.close();

        stmt.close();
        conn.close();
    }
}
// java -classpath .;ojdbc14.jar Test100
```







# Day 9 

## Oracle DB

### Create

```sql
create table study10t( 
	id Number(3),
	data varchar2(10)	
);
```

​	오라클 숫자 : NUMBER(3) -최대 세자리수 숫자

​	VARCHAR2 - 오라클에서 만든 속도가 조금 빠른 VARCHAR

### INSERT

```sql
INSERT INTO study10t values (100, 'HelloWorld');
```



create

```sql
CREATE TABLE study011t ( 
	id NUMBER(5),
    data CHAR(10)
);
```

### Sequence

```sql
CREATE SEQUENCE seq_study11;
```

--오라클과 mysql 은 일련번호 만드는 방법이 틀리다

​	: mysql auto_increment primary key를 썼다

insert  시퀀스

```sql
INSERT INTO study011t VALUES (seq_study11.NEXTVAL , 'apple');
```



### SELCT

```sql
select * from study011t;
```



```sql
SELECT id, data || '*' FROM study011t;
```

 -- mysql 의 concat 과 동일한 기능을 수행한다.  문자열 붙이기

결과

        ID DATA||'*'
---------- ----------------------
         1 apple     *
         2 apple     *
         3 apple     *
         4 apple     *
--char(10) 으로 선언한 필드에 'apple' 을 넣으면 'apple     ' 돤다, char는 고정길이 이므로

​	mysql 은 그냥 'apple' 이 된다.

### TRIM()

```sql
select id, TRIM(data) || '*' from study011t;
```

-좌/우 공백 문자를 제거하는 역할을 한다.



### 자료형 date  -날짜시간

```sql
create table study12t(
	the_time date
);
```



#### sysdate

```sql
insert into study12t values (sysdate);
```



-oracle 의 날짜시간은 date 자료형을 이용한다. 

​	현재 시간은 sysdate 를 이용한다.

​	보여지는 형식은 to_char 이용하여 형식을 지정하면 된다.

```sql
select to_char( the_time, 'YYYY-MM-DD' ) from study12t;
```

```sql
select to_char(the_time, 'YYYY-MM-DD HH24:MI:SS' ) from study12t;
```



### school.sql.txt

```sql
DROP TABLE StudentT;
DROP TABLE SubjectT;
DROP TABLE ScoreT;

CREATE TABLE StudentT(
	stId CHAR(5),
	name VARCHAR(9),
	addr VARCHAR(9)
);

INSERT INTO StudentT VALUES('10101','홍길동','역삼동');
INSERT INTO StudentT VALUES('10102','고길동','개포동');
INSERT INTO StudentT VALUES('10103','이기자','역삼동');
INSERT INTO StudentT VALUES('10104','박기자','한남동');
INSERT INTO StudentT VALUES('10105','김영삼','홍제동');
INSERT INTO StudentT VALUES('10106','김대중','한남동');

CREATE TABLE SubjectT(
	subId   CHAR(4), 
	name   VARCHAR(9) 
);

INSERT INTO SubjectT VALUES ('KOR1','국어1');
INSERT INTO SubjectT VALUES ('ENG1','영어1');
INSERT INTO SubjectT VALUES ('MAT1','수학1');

CREATE TABLE ScoreT(
	stId  CHAR(5),
	subId CHAR(4), 
	score TINYINT
);

INSERT INTO ScoreT VALUES('10101','KOR1',60);
INSERT INTO ScoreT VALUES('10101','ENG1',80);
INSERT INTO ScoreT VALUES('10101','MAT1',90);

INSERT INTO ScoreT VALUES('10102','KOR1',90);
INSERT INTO ScoreT VALUES('10102','MAT1',90);
INSERT INTO ScoreT VALUES('10102','ENG1',100);

INSERT INTO ScoreT VALUES('10103','KOR1',70);
INSERT INTO ScoreT VALUES('10104','KOR1',80);
INSERT INTO ScoreT VALUES('10105','KOR1',50);
INSERT INTO ScoreT VALUES('10106','KOR1',60);

INSERT INTO ScoreT VALUES('10103','ENG1',90);
INSERT INTO ScoreT VALUES('10104','ENG1',70);
INSERT INTO ScoreT VALUES('10105','ENG1',60);
INSERT INTO ScoreT VALUES('10106','ENG1',80);

INSERT INTO ScoreT VALUES('10103','MAT1',70);
INSERT INTO ScoreT VALUES('10104','MAT1',70);
INSERT INTO ScoreT VALUES('10105','MAT1',80);
INSERT INTO ScoreT VALUES('10106','MAT1',60);

CREATE TABLE Score2T (
	stId CHAR(5),
	name VARCHAR(9),
	addr VARCHAR(9),
	kor1 TINYINT,
	eng1 TINYINT,
	mat1 TINYINT
);

INSERT INTO Score2T VALUES('10101','홍길동','역삼동',60,80,90);
INSERT INTO Score2T VALUES('10102','고길동','개포동',90,90,100);
INSERT INTO Score2T VALUES('10103','이기자','역삼동',70,90,70);
INSERT INTO Score2T VALUES('10104','박기자','한남동',80,70,70);
INSERT INTO Score2T VALUES('10105','김영삼','홍제동',50,60,80);
INSERT INTO Score2T VALUES('10106','김대중','한남동',60,80,60);

```

TINYINT -> NUMBER(3) 으로 변경



```sql
DROP TABLE StudentT;
DROP TABLE SubjectT;
DROP TABLE ScoreT;

CREATE TABLE StudentT(
	stId CHAR(5),
	name VARCHAR2(9),
	addr VARCHAR2(9)
);

INSERT INTO StudentT VALUES('10101','홍길동','역삼동');
INSERT INTO StudentT VALUES('10102','고길동','개포동');
INSERT INTO StudentT VALUES('10103','이기자','역삼동');
INSERT INTO StudentT VALUES('10104','박기자','한남동');
INSERT INTO StudentT VALUES('10105','김영삼','홍제동');
INSERT INTO StudentT VALUES('10106','김대중','한남동');

CREATE TABLE SubjectT(
	subId   CHAR(4), 
	name   VARCHAR2(9) 
);

INSERT INTO SubjectT VALUES ('KOR1','국어1');
INSERT INTO SubjectT VALUES ('ENG1','영어1');
INSERT INTO SubjectT VALUES ('MAT1','수학1');

CREATE TABLE ScoreT(
	stId  CHAR(5),
	subId CHAR(4), 
	score NUMBER(3)
);

INSERT INTO ScoreT VALUES('10101','KOR1',60);
INSERT INTO ScoreT VALUES('10101','ENG1',80);
INSERT INTO ScoreT VALUES('10101','MAT1',90);

INSERT INTO ScoreT VALUES('10102','KOR1',90);
INSERT INTO ScoreT VALUES('10102','MAT1',90);
INSERT INTO ScoreT VALUES('10102','ENG1',100);

INSERT INTO ScoreT VALUES('10103','KOR1',70);
INSERT INTO ScoreT VALUES('10104','KOR1',80);
INSERT INTO ScoreT VALUES('10105','KOR1',50);
INSERT INTO ScoreT VALUES('10106','KOR1',60);

INSERT INTO ScoreT VALUES('10103','ENG1',90);
INSERT INTO ScoreT VALUES('10104','ENG1',70);
INSERT INTO ScoreT VALUES('10105','ENG1',60);
INSERT INTO ScoreT VALUES('10106','ENG1',80);

INSERT INTO ScoreT VALUES('10103','MAT1',70);
INSERT INTO ScoreT VALUES('10104','MAT1',70);
INSERT INTO ScoreT VALUES('10105','MAT1',80);
INSERT INTO ScoreT VALUES('10106','MAT1',60);

CREATE TABLE Score2T (
	stId CHAR(5),
	name VARCHAR(9),
	addr VARCHAR(9),
	kor1 NUMBER(3),
	eng1 NUMBER(3),
	mat1 NUMBER(3)
);

INSERT INTO Score2T VALUES('10101','홍길동','역삼동',60,80,90);
INSERT INTO Score2T VALUES('10102','고길동','개포동',90,90,100);
INSERT INTO Score2T VALUES('10103','이기자','역삼동',70,90,70);
INSERT INTO Score2T VALUES('10104','박기자','한남동',80,70,70);
INSERT INTO Score2T VALUES('10105','김영삼','홍제동',50,60,80);
INSERT INTO Score2T VALUES('10106','김대중','한남동',60,80,60);

```



Q. 역삼동에 사는 학생의 국어성적을 서브쿼리로 구하세요.

```sql
SELECT * from scoret where subid ='KOR1' AND stid in
(select stid from studentt where addr LIKE '%역삼%');
```



Q. 학생별 평균 점수를 group by 로 구해보세요.

​	( group by 에서 지정한 컬럼은 select 절에서 쓸 수 있다. )  

```sql
SELECT stid, AVG(score) FROM scoret GROUP BY stid;
```



### JOIN

```sql
SELECT *FROM studentt INNER JOIN scoret ON studentt.stid = scoret.stid;
```

​	위가 국제 표준

​	아래는 회사맘대로 오라클변형

오라클은 이렇게 이너조인을 할 수 있다.(좀 더 직관적)

```sql
SELECT * FROM studentt, scoret where studentt.stid = scoret.stid;
```

질문 강사님은 오라클만 된다고 하셨으나 mysql도 되었다. 

-답변 버전마다 다르기 때문에 안된다고 하셨다.

...

```sql
insert into subjectt values ('PHY1', '물리');
```



```sql
SELECT * FROM subjectt LEFT OUTER JOIN scoret
ON subjectt.subid = scoret.subid;
```



오라클에서 outer join 변형

```sql
Select * from subjectt , scoret where subjectt.subid = scoret.subid(+);
```

-null값을 붙이는 쪽에 (+) 표시

 -- INNER JOIN ON , OUTER JOIN ON 국제표준 SQL   			잘 모르겠으면 이거쓰자

​	각 DB별로 변형 SQL 을 탑재      오라클이 국제표준을 뒤흔들정도로 영향력이 큼

Oracle 의 변형방법을 다른 DB업체들이 따라하기도 한다.

오라클만 쓰는 사람들은 오라클의 방법만을 고집하는 경우가 많다.

강사님 추천 국제표준으로 외우고 오라클 방법은 알아두자



### as

```sql
SELECT stid, avg(score) as avg from scoret group by stid;
```

### from서브쿼리

```sql
select * from (SELECT stid, avg(score) as avg from scoret group by stid);
```

: select 시 테이블의 별칭을 줄때는 as 사용하지 않는다.

 (mysql 에서는 준다)

oracle

```sql
select x.stid , x.avg from (SELECT stid, avg(score) as avg from scoret group by stid) x;
```

mysql

```sql
select x.stid , x.avg from (SELECT stid, avg(score) as avg from scoret group by stid) AS x;
```



INNER JOIN 과 테이블 별칭

```sql
select y.name, x.avg from (SELECT stid, avg(score) as avg from scoret group by stid) x , studentt y where x.stid = y.stid;
```

-- as 문법 , join 의 문법이 약간 틀리다.

​	하지만 기본 개념은 동일하다.

"거의 모든 데이터베이스의 기본 개념은 같다."

-하나 해 놓으면 다른 거 어렵지 않다.



### Contstraint in Oracle

-Primary key, foreign key, check , unique, not null(잘 안씀)

```sql
ALTER TABLE studentt ADD constraint pk_studentt_stid PRIMARY KEY(stid);
```

확인
```sql
INSERT INTO studentt VALUES ( '10101','한동희' , '개포동')
```
1행에 오류:
ORA-00001: 무결성 제약 조건(HR.PK_STUDENTT_STID)에 위배됩니다

참조무결성 : FK쪽에는 PK 에 없는 데이터는 존재하면 안된다.





```sql
ALTET TABLE scoret ADD CONSTARINT fk_scoret_stid FOREIGN KEY (stid) REFERENCES studentt (stid);
```

```sql
alter table scoret add constraint fk_scoret_stid foreign key (stid) references studentt (stid);
```

두개중 아래는 됨 위는 안됨 차이 생각해보자 오타인거같다.



```sql
delete from studentt where stid = '10101';
```

이유: scoret가 참조하고있는 것을 삭제하기 떄문에 에러뜸. 

```sql
insert into scoret values ('10109','KOR1', 100);
```

이유 : scoret의 stid가 studentt 의 없는 값을 가짐



```sql
alter table scoret add constraint fk_scoret_subid foreign key (subid) references subjectt(subid);
```

ORA-02270: 이 열목록에 대해 일치하는 고유 또는 기본 키가 없습니다.

(FK CONSTRAINT 는 먼저 참조할 대상 PK Constraint 가 존재해야 생성가능하다.)



```sql
alter table scoret add constraint ck_scoret_score check (score >= 0 and score <= 100);
```

확인

```sql
 insert into scoret values ('10101','PHY1', 120);
```

ORA-02290: 체크 제약조건(HR.CK_SCORET_SCORE)이 위배되었습니다



```sql
alter table subjectt add constraint uq_subject_subid unique (subid);
```

: not null 은 보장안함. no duplicate 는 보장

```sql
insert into subjectt values (null, '없음0');
```

잘 됨  거기에 null 값이 없는 것이기 때문에  null 은 중복허용



```sql
insert into subjectt values ('KOR1', '없음0')
```

ORA-00001: 무결성 제약 조건(HR.UQ_SUBJECT_SUBID)에 위배됩니다. 허용x



처음에 제약조건을 거는 것보단 나중에 변경해주는 것이 좋다.  이유 개별 기능테스트를 위해서

예시) 회원가입 담당자가 일 다 안한 상황에서 게시판 담당자가 테스트 들어가려면 ?)



### constrain 지우기



```sql
alter table scoret drop constraint ck_scoret_score;
```

```sql
alter table subjectt drop constraint uq_subject_subid
```

FK 부터 지워야함 이유 PK가 있어야 FK이 있기 떄문

```sql
alter table scoret drop constraint fk_scoret_stid;
```

```sql
alter table studentt drop constraint pk_studentt_stid;
```

tip 이름 붙이는 원칙이 있으면 관리할 때 편하다.

\ex)" 제약조건\_테이블명_필드명"

......

### 방명록만들기

```sql
create table bangmyung_t(
	no int,
    gul varchar2(100),
    the_time date
);
```

시퀀스 만들기

```sql
create sequence seq_bangmyung;
```



```sql
insert into bangmyung_t values(seq_bangmyung.nextval, '만나서 반갑습니다.', sysdate);
```



#### mysql ver

```sql
create table bangmyung_t(
	no int auto_increment primary key,
    gul varchar(100),
    the_time datetime
);
```



```sql
insert into bangmyung_t values(default , '만나서 반갑습니다.', now());
```

+----+----------------------------+---------------------+
| no | gul                        | the_time            |
+----+----------------------------+---------------------+
|  1 | 만나서 반갑습니다.         | 2019-07-26 14:15:15 |
|  2 | 만나서 반갑습니다.         | 2019-07-26 14:15:20 |
|  3 | 만나서 반갑습니다.         | 2019-07-26 14:15:21 |
|  4 | 만나서 반갑습니다.         | 2019-07-26 14:15:21 |
+----+----------------------------+---------------------+
4 rows in set (0.00 sec)





## 다시 자바

### Test101.java



### Test102.java

```java
package day0725;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

class BangMyungVO {
    private Integer no = null;
    private String gul = null;
    private String theTime = null;

    public Integer getNo() {
        return no;
    }

    public void setNo(Integer no) {
        this.no = no;
    }

    public String getGul() {
        return gul;
    }

    public void setGul(String gul) {
        this.gul = gul;
    }

    public String getTheTime() {
        return theTime;
    }

    public void setTheTime(String theTime) {
        this.theTime = theTime;
    }
}

public class Test102 {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        Class.forName("oracle.jdbc.driver.OracleDriver");
        Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521/XE", "HR", "HR");

        Statement stmt = conn.createStatement();

        String sql = "select * from bangmyung_t";
        ResultSet rs = stmt.executeQuery(sql);
        List<BangMyungVO> ls= new ArrayList<BangMyungVO>();
        while (rs.next()) {
            BangMyungVO vo = new BangMyungVO();
            vo.setNo(rs.getInt("no"));
            vo.setGul(rs.getString("gul"));
            vo.setTheTime(rs.getString("the_time"));
            ls.add(vo);
        }
        for(BangMyungVO t : ls){
            System.out.println(t.getNo() + t.getGul() + t.getTheTime());
        }
        rs.close();
        stmt.close();
        conn.close();
    }
}

```





### Test103.java  connection과 try finally

```java
package day0725.test103;

import java.sql.*;

public class Test103 {
    /*
        executeUpdate 상황엣 에러나도 conn.close() 는 되어야 한다? ㅇㅇ
        finally 영역은 try 영역에서 에러가 나건 안나건 무조건 실향한다.
        :stmt.close() conn.close() 를 finally 로 옮김.
        : 변수선언 정리
        getConnection() 에서 에러나면? conn 과 stmt 는 null 인 채로 finally 행
        그러면 stmt.close()가 참조형변수가 null이므로 메소드를 실행할 수 없어 에러가남
        stmt.close() conn.close() 가 stmt , conn 이 null 이 아닐때만
            호출하도록 개선했다.
            : 프로젝트 때 마르고 닳도록 쓸거다
     */
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        Class.forName("oracle.jdbc.driver.OracleDriver");
        addGul("HelloApple");

    }

    private static void addGul(String gul) throws ClassNotFoundException, SQLException {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521/XE", "HR", "HR");

            stmt = conn.createStatement();
            String sql = "insert into bangmyung_t values (seq_bangmyung.nextval,'" + gul + "' , sysdate)";
            stmt.executeUpdate(sql);
        } catch (Exception e) {
            throw e;
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (conn != null) {
                conn.close();
            }
            System.out.println("all closesd");
        }


    }
/*
       함수로 선언해서 재사용성을 높였다.
       SQL 문장에서 에러 -> stmt.executeUpdate(sql) 에서 예외발생
       -> conn.close() 실행 안된다. -> 이건 좀 크다  (conn 은 빨리 끊어야)

    private static void addGul(String gul) throws ClassNotFoundException, SQLException {

        Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521/XE", "HR", "HR");

        Statement stmt = conn.createStatement();
        String sql = "insert into bangmyung_t values (seq_bangmyung.nextval,'" + gul + "' , sysdate)";
        stmt.executeUpdate(sql);

        stmt.close();
        conn.close();
    }
*/
}


```



### Test104.java

### Test105.java

```java
import java.util.List;
import temp.BangMyungDAO;
import temp.BangMyungVO;
//import day0725.Test105.temp.*; 만약에 다른파일이 있을경우 에러 날 수 있음
public class Test105 {
    public static void main(String[] args) throws Exception{
        BangMyungDAO.addGul("끝이 보이냐");
        List<BangMyungVO> ls = BangMyungDAO.findAll();

        for ( BangMyungVO vo:ls ) {
            System.out.println(vo.getNo()+"\t" + vo.getGul() +"\t" +vo.getTheTime());

        }
    }
}

```



#### BangMyungVO

```java
package temp;

public class BangMyungVO {
    private Integer no = null;
    private String gul = null;
    private String theTime = null;

    public Integer getNo() {
        return no;
    }

    public void setNo(Integer no) {
        this.no = no;
    }

    public String getGul() {
        return gul;
    }

    public void setGul(String gul) {
        this.gul = gul;
    }

    public String getTheTime() {
        return theTime;
    }

    public void setTheTime(String theTime) {
        this.theTime = theTime;
    }
}

```

#### BangMyungDAO

```java
package temp;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
// 컴파일하기
/*
    폴더구조가
    .
    temp
    Test105.java
    BangMyungVO.java
    BangMyungDAO.java
    ojdbc14.jar

    ...
  	이 경우
    1. 쓰임을 당하는 BangMyungVO.java부터 컴파일  package temp;
    javac -d .  BangMyungVO.java
    2.package temp;
    javac -d .  BangMyungDAO.java
    3. import temp.BangMyungDAO; import temp.BangMyungVO;
    javac -classpath .;ojdbc14.jar Test105.java
    +Test105에는 이렇게 있어야한다.
     import temp.BangMyungDAO;
	import temp.BangMyungVO;
	
    
 */
public class BangMyungDAO { //Data Access Object

    static {
        try {
            Class.forName("oracle.jdbc.driver.OracleDriver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    public static List<BangMyungVO> findAll() throws Exception {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        List<BangMyungVO> ls = new ArrayList<BangMyungVO>();
        try {
            conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521/XE", "HR", "HR");
            stmt = conn.createStatement();
            String sql = "select * from bangmyung_t";
            rs = stmt.executeQuery(sql);
            while (rs.next()) {
                BangMyungVO vo = new BangMyungVO();
                vo.setNo(rs.getInt("no"));
                vo.setGul(rs.getString("gul"));
                vo.setTheTime(rs.getString("the_time"));
                ls.add(vo);
            }
        } catch (SQLException e) {
            throw e;  //에러 나면 잡고 finall 거치고 다시 발생
        } finally {
            if (rs != null) {
                rs.close();
            }
            if (stmt != null) {
                stmt.close();
            }
            if (conn != null) {
                conn.close();
            }
            System.out.println("All closed");
        }


        return ls;
    }
    public static void addGul(String gul) throws ClassNotFoundException, SQLException {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521/XE", "HR", "HR");

            stmt = conn.createStatement();
            String sql = "insert into bangmyung_t values (seq_bangmyung.nextval,'" + gul + "' , sysdate)";
            stmt.executeUpdate(sql);
        } catch (Exception e) {
            throw e;
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (conn != null) {
                conn.close();
            }
            System.out.println("all closesd");
        }


    }

}

```



 

### 트랜잭션

한번에 전부 실행성곡하거나 실행하지말거나 해야하는 것

ex) 비디오 대여점 

```
대여 insert
대여가능 -> 대여중
예치금 --
```

```
대여중 삭제 
대여기록 insert
연체료를 예치금에서 뺀다
대여중 -> 대여가능
```

```
댓글입력
댓글수 ++
```

```
매성 +2
재고 -2
```


![트랸잭션및커밋](.\img\트랸잭션및커밋.jpg)



### Test106.java

```java
package day0725.Test105.temp;
import java.sql.*;
/*
    conn 을 통해서 executeUdate 하면 LOG를 거쳐서 Table 에 저장된다.
    jdbc 는 autoCommit 을 지원한다.
    (즉 executeUpdate 시에 무조건 commit 이 자동으로 먹는다 )

    conn.setAutoCommit( false ) : commit 이 자동으로 먹지 않는다
 */
public class Test106 {
    public static void main(String[] args) throws Exception{
        Class.forName("oracle.jdbc.driver.OracleDriver");
        Connection conn =DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:XE","HR","HR");
        conn.setAutoCommit( false );
        Statement stmt = conn.createStatement();
        stmt.executeUpdate("insert into test_tx  values ( 101 )");
        stmt.executeUpdate("insert into test_tx values ( 102 )");
        stmt.executeUpdate("insert into test_tx values ( 103 )");
        stmt.executeUpdate("insert into test_tx values ( 104 )");
        stmt.close();

        conn.commit();         //로그를 테이블에 반영시키고 비운다.
//        conn.rollback();    //로그를 그냥 비운다.
        conn.close();
    }
}
/*
    insert into test_xt values ( 100 );

 */
```



### Test106_2.java

```java
package day0725.Test105.temp;

import java.sql.*;

/*
    conn 을 통해서 executeUdate 하면 LOG를 거쳐서 Table 에 저장된다.
    jdbc 는 autoCommit 을 지원한다.
    (즉 executeUpdate 시에 무조건 commit 이 자동으로 먹는다 )

    conn.setAutoCommit( false ) : commit 이 자동으로 먹지 않는다
 */
public class Test106_2 {
    public static void main(String[] args) throws Exception {
        Class.forName("oracle.jdbc.driver.OracleDriver");

        Connection conn = null;
        Statement stmt = null;
        try {
            conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:XE", "HR", "HR");
            conn.setAutoCommit(false);
            stmt = conn.createStatement();
            stmt.executeUpdate("insert into test_tx  values ( 101 )");
            stmt.executeUpdate("insert into test_tx values ( 102 )");
            stmt.executeUpdate("insert into test_tx values ( 103 )");
            stmt.executeUpdate("insert into test_txa values ( 104 )");
            //제대로 됐으니 커밋
            conn.commit();         //로그를 테이블에 반영시키고 비운다.
        } catch (SQLException e) {
            if (conn != null) {
                conn.rollback();    //로그를 그냥 비운다.
            }
            throw e;
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (conn != null) {
                conn.close();
            }
        }


    }
}
/*
    insert into test_xt values ( 100 );

 */
```



rollback() 이 없다면 conn.close() 시 commit해줌 즉

3개되고 하나가  에러난다면 3개는 들어감

