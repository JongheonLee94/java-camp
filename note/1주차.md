# Day1.자바기초

| byte  | short | int   | long  | float | double | boolean | char  |
| ----- | ----- | ----- | ----- | ----- | ------ | ------- | ----- |
| 1byte | 2byte | 4byte | 8byte | 4byte | 8byte  | 1byte   | 1byte |

<u>정수 저장용(byte, short, int , long,)  실수 (float, double), 논리(boolean), 문자(char)</u>    

정수는 int가 가장 많이 씀. 

cli 자바 컴파일

javac filename.java

cli 자바 실행

java filename

# Day2.자바기초 및 C	

---

## 2일차개요



## 자바

### <u>코드를 잘 짜는 비결</u> 

- 잘 쪼개서 짠다. 
- 자신의 보폭을 잘 파악해야 한다.
- 버리는 코드를 잘 짜야한다.



#### 쪼개서짜기 예시(자신이 한번에 짤 수 있는 만큼)

​	<u>목표)일년마다 100만원씩 넣고 연이자 6.6%인 복리</u>

```java
public class HelloWorld{
	public static void main(String[] args) {

		double money = 100;

        System.out.printf( money );
    }
}
```
##### -- ##commit 1. 돈 넣음
```java
public class HelloWorld{
	public static void main(String[] args) {

		double money = 100;

        System.out.printf( money );

		money = money+ money*0.066;

		System.out.printf( money );

		money = money+ money*0.066;

		System.out.printf( money );

		money = money+ money*0.066;

		System.out.printf( money );

		money = money+ money*0.066;

		System.out.printf( money );

		money = money+ money*0.066;

    }
}
```
##### --##commit 2. 5년치 이자
```java
public class HomeWork2 {
    public static void main(String[] args) { 
     
        double money=100;//자동형변환  
        for (int i = 0; i < 5; i++) {  
            money = money*1.066;    
        }    
        System.out.println( money +"만원");  
    }
}
```
##### -- ## commit 3.반복문으로 변경

```java
public class HomeWork2 {
    public static void main(String[] args) { 
     
        double money=100;//자동형변환  
        for (int i = 0; i < 100; i++) {  
            money = money*1.066;    
        }    
        System.out.println( money +"만원");  
    }
}
```

##### -- ## commit 4. 100년치로 변경

```Java
public class HomeWork2 {
    public static void main(String[] args) { 
        double money=0;//자동형변환  
        for (int i = 1; i <= 100; i++) {  
            money =money + 100;     
            money = money*1.066;    
        }    
        System.out.println("money = " + money +"만원");    
    }
}
```

##### -- ## commit 5. 매년 100만원씩 넣는 것 추가

하는이유:지금까지 어떻게 했는지 백업하여 잘 되지 않았을 때 돌아가서 할 수 있다.
```c
#include <stdio.h>

int main(){
	int i;
	int j; 
	i = 100;
	j = i;
	printf("%d, %d\n",i,j);
	return 0;
}
	/* Test14.c
	c언어의 경우에는 변수의 선언은 위에 몰아서 하는게 원칙이다.
	
	java는 int= i = 100;이 허용됩니다.
	c는 int i; i= 100; 으로 선언과 대입은 철저히 구분이 원칙 
	*/ 
```

---





## C 포인터

### Test15.c 포인터변수

```c
#include <stdio.h>

int main(){
	int* t;
	int* l;
	int i;
	//아래 코두애소 *t와 i는 동일하다. 이유는? 
	i =100;
	t= &i;
    l=t;
	printf("i = %d , i의 주소 = %d, t = %d, t의 실제 값은? %d \n ",i,&i,*t,t);
    printf("%d",l);
	if(&i ==t){
		printf("i의 주소 &i는 t가 가진 값과 같다. \n");
	} 
	*t=200;
	printf("i의 값은?%d",i);
	printf("t를 바꾸었는데 i의 값이 바뀌었다.\n t가 i를 가리키고 *t는 t가 가리킨 주소에 있는 메모리의 값을 바꾸었기 때문이다.\n i를 바꾼 것과 같다.\n");
}
/* Test15.c
	c언어의 경우에는 자료형의 포인터 형 변수가 존재한다. 
	*/ 
```



**c언어의 경우에는 자료형의 포인터 형 변수가 존재한다.***
**자료형 변수의 대입과 포인터의 대입은 다르다.**
**포인터의 대입은 오른쪽이 가리키는 대상을**
 	**왼쪽이 가리키게 된다.**
	 **자료형 변수의 대입은 오른쪽 변수의 값이 복사되어** 
	 	왼쪽변수에 들어간다.****	

**포인터변수**

​		**포인터 변수△는 가리키기 위해** 

​     	**일반 변수□는 값을 저장하기 위해**

​    	**i □100**

​	**t △↗**

​	***t  =>t가 가리키는 대상의 공간**

### Test17.c 

void* void포인터
```c
#include <stdio.h>

int main(){
	int i;
	float l;
	void* t;
	int* h; 
	//void* 변수는 어떤 기억공간이든 다 기리킨다. 
	i = 100;
	l = 3.14;
	t = &l;
	t = &i;
	h = (int*)t; //형변환하여 사용한다.
    //t가 가리키는 지점을 기준으로 int형 기억공간 만큼을 확장한 기억공간을 h가 가리킨다.
	

	//printf("%d\n",*t);  //가리킬 수는 있으나 실체에 접근은 할 수 없다. 
	printf("%d\n",*h);
	return 0; 
}
/* Test17.c
	void포인터변수는 변수의 꼭지점만 가리킨다고 보자. 그래서 안은 들어갈 수 없는 것이라고 생각하자.
    
	*/ 
```



void* 쓰는 곳이 궁금하다. 나중에 찾아보자

리눅스 커널 안에 void* 가 많이 사용한다고 한다.

(함수포인터도 있다.)



### Test018.c
```c
#include <stdio.h>
int add( int i , int j){ //int i는 매개변수: 알종의 로컬변수로 함수를 호출할 때 넘겨준 값을 대입한다.
    int t;
    t= i+j;
	return t;
} 
/*main은 가장 먼저 실행되는 함수다. 함수 안에 변수 선언? 가능
	로컬변수는 "함수 안에서 선언된 변수"
	-함수가 호출되는 시정에 메모리 할당. 호출 끝나면 소거.
	
	=의 오른편이 먼저 동작. 선언된 함수를 호출한다.
	함수에는 매개변수가 선언된다.
		호출시에는 값을 명시한다. ( 선언 아니다. )
		매개변수는 호출시 명시된 값으로 대입당한다.
		매개변수도 로컬변수다. 함수가 호출될 때  생성된다.
		
	t 로컬변수가 호출시에 생성되고 i + j 값을 대입당한다. (30)
	함수의 종료에는 return (변수/ 값) 인데
    	(변수 / 값 )은 함수의 리턴타입을 만족해야 한다.(int)
    r = add( 10, 20 ); 의 결과로 return t가 동작하면
    r = t의 현상이 벌어진다고 보면 된다.
*/
int main(){
	int r;
	r = add (10, 20);
	printf("%d \n ",r );
	return 0; 
}
/* Test18.c
	함수 선언
	[유일한 리턴타입] [아름] ( 매개변수는 0~...) {...}
	
	함수안에서 선언된 변수를 local 변수라고 한다.
*/ 
```

함수의 개념 

x는 하나의 결과 y를 가진다.

여러 x가 하나의 y를 가리킬 수 있다.

프로그래밍 함수도 마찬가지이다. 

리턴은 하나 파라미터는 여러개 가능 수학에서도 z=f(x, y) 같은 것처럼

local 변수: 함수 안에서 선언된 변수로 함수 호출될 때 생성 함수 끝날 때 소멸  구분자가 끝나면 사라진다.

전역 변수 : 함수 밖에서



### Test020.c    함수포인터

```c
#include <stdio.h>
int add(int i , int j){
	int k;
	k= i + j;
	return k;
}
int main(){
int r;
//아래와 같이 선언된 변수 fp는 함수를 가리킬 수 있다.
//리턴 타입이 int , 매개변수가 int , int 형태로 선언된 함수를 .
int (*fp)(int,int);
fp = add;

//fp라는 함수가 아닌 fp변수가 가리키는 함수를 호출한다. 
r = add(10,20);
printf("%d \n",r);
return 0;
}
/*Test020.c 

*/
```



### Test021.c 함수포인터로 써보기

```c
#include <stdio.h>
int apple(int i , int j){
	return 100;
}
int banana(int i , int j){
	return 200;
}
int main(){
int r;
int (*fp)(int,int);

fp = apple;
r= fp( 10 , 20 );  //100
printf("%d \n", r);

fp=banana;
r= fp( 10 , 20 );  //200
printf("%d \n", r);
return 0;
}
/*Test021.c 

*/
```

### Test022.c 단리복리 

---



## 다시 자바 객체생성

### Test023.java   Class 와 Instance 개념 및 사용법 

```java
/*
    클래스를 선언할 수 있다. class [class name]{...}  c는 class가 없다.
    -변수선언, 함수선언 가능하다.
    -변수의 대입. 연산. 함수 호출 등등 ... 은 불가능하다.
 */
class Apple{
    int i;
    //i = 100;  에러난다. 클래스 내부 대입불가
    int add (int i , int j ){ return 100;}
//    System.out.println(add(10,20)); 함수호출 불가

}
/*
    클래스를 선언하고 , 그 이름으로 변수 선언이 가능한데
        이런 변수를 참조형 변수라고 한다. (살은 다 포인터)

    클래스를 선언하고 , new 를 이용해서 인스턴스를 만들 수 있다.
        (클래스와 new  를 이용하면 뭔가가 만들어진다 : instance)
    클래수 이름으로 선언된 변수는 참조형 변수이고,
        이것은 해당 클래스를 이용해 만들어진 인스턴스를 가리킬 수 있다.
     클래스는 설계도다 (변수 함수 선언) -실제로 활용은 안된다.
     new 를 이용해서 인스턴스를 만든다. 그 안에는 변수와 함수가 들어있다.
     인스턴스는 이름이 없다. 단 포인터로 실체에 접근이 가능하다.

     t.i : 이것은 t가 가리키는 인스턴스가 가지고 있는 변수 i 라는 얘기.
     t,add( 10 , 20 ): t가 가리키는 인스턴스가 가지고 있는 함수 add 호출

     ( 변수와 함수를 실제로 보유하고 있는 것은 참조형 변수가 아니라 인스턴스다.)

     */
public class Test023 {
    public static void main(String[] args) {
        Apple t = new Apple();
        t.i = 100;
        System.out.println(t.add(10,20));
    }
}

```

Class는 설계도이고 instance가 설계도로 만든 로봇이다.

설계도인 class에는 명시(변수, 함수 선언)만 할뿐 사용할 수는 없다.

인스턴스의 변수와 함수는 사용할 수 있고  이름이 없다. 

그러나 참조형 변수로 이용할 수 있다.

인스턴스가 로봇이라면 참조형 변수는 리모컨이다.





### Test024.c
```c
#include <stdio.h>
#include <stdlib.h>
 //두개의 변수를 묶어서 apple 이라는 이름으로 '구조체'를 정의 
struct apple{
	int i;
	int add;
};

int main(){
	//apple 구조체의 기억공간을 가리킬 수 있는 포인터 변수 t 선언 
	struct apple* t; 
	//구조체 크기의 기억공간 할당. t 포인터가 해당 공간을 가리킴
	//- 이 공간은 이름이 없고, 포인터로만 접근이 가능하다. 
	//- 이 공간은 로컬변수 아님. 따라서 자동삭제 안된다.
	//free(t)는 t가 가리키는 대상을 삭제한다. 
	t = (struct apple*)malloc( sizeof(struct apple));  
	//포인터t가 가리키는 대상 안에 있는  i  변수에 대입한다. 
	t->i = 100;
	t->add = 20;
	printf("%d \n", (t->i+t->add));
	
	free(t);
	return 0;	
}
/*
	Test024.c
*/
```
malloc이 new와 비슷

malloc으로 만들면 이름이 없다. 그래서 포인터로 이용

Test024.c 변경


```c
#include <stdio.h>
#include <stdlib.h>
 //두개의 변수를 묶어서 apple 이라는 이름으로 '구조체'를 정의 
typedaf struct apple{
	int i;
	int add;
}Apple;

int main(){
	//apple 구조체의 기억공간을 가리킬 수 있는 포인터 변수 t 선언 
	Apple* t; 
	//구조체 크기의 기억공간 할당. t 포인터가 해당 공간을 가리킴
	//- 이 공간은 이름이 없고, 포인터로만 접근이 가능하다. 
	//- 이 공간은 로컬변수 아님. 따라서 자동삭제 안된다.
	//free(t)는 t가 가리키는 대상을 삭제한다. 
	t = (Apple*)malloc( sizeof(Apple));  
	//포인터t가 가리키는 대상 안에 있는  i  변수에 대입한다. 
	t->i = 100;
	t->add = 20;
	printf("%d \n", (t->i+t->add));
	
	free(t);
	return 0;	
}
/*
	Test024.c
*/
```



Test024.c 변경 함수포인터로 add를 가리켜 호출
```c

#include <stdio.h>
#include <stdlib.h>
 //두개의 변수를 묶어서 apple 이라는 이름으로 '구조체'를 정의 
int apple_add(int i,int j){
	return 100;
}
typedef struct apple{
	int i;
	int (*add)(int,int);
}Apple;

int main(){
	//apple 구조체의 기억공간을 가리킬 수 있는 포인터 변수 t 선언 
	Apple* t; 
	//구조체 크기의 기억공간 할당. t 포인터가 해당 공간을 가리킴
	//- 이 공간은 이름이 없고, 포인터로만 접근이 가능하다. 
	//- 이 공간은 로컬변수 아님. 따라서 자동삭제 안된다.
	//free(t)는 t가 가리키는 대상을 삭제한다. 
	t = (Apple*)malloc( sizeof(Apple));  
	//포인터t가 가리키는 대상 안에 있는  i  변수에 대입한다. 
	t->i = 100;
	t->add = apple_add;
	printf("%d \n", (t->i + t->add(10,20)));
	
	free(t);
	return 0;	
}
/*
	Test024.c
*/
```

Test024변경  구조체


```c
#include <stdio.h>
#include <stdlib.h>
 //두개의 변수를 묶어서 apple 이라는 이름으로 '구조체'를 정의 
int apple_add(int i,int j){
	return 100;
}
typedef struct apple{
	int i;
	int (*add)(int,int);
}Apple;

//인스턴스 생성과 유사한 동작을 하게 된다.
//이렇게 해서 생성되고, 이것을 가리키는 포인터를 톻해서
//	함수와 변수가 접근되어 질 수 있다. 
Apple* new_Apple(){
	Apple* n;
	n = (Apple*)malloc( sizeof(Apple));
	n->add = apple_add;
	return n;
}
int main(){
	Apple* t; 

	t = new_Apple();  
	t->i = 100;
	t->add = apple_add;
	printf("%d \n", (t->i + t->add(10,20)));
	
	free(t);
	return 0;	
}
/*
	Test024.c
*/
```

가비지 컬렉터는 그 인스턴스를 가리키는 참조형변수가 0개가 되면 수거를 하는데

수거자체는 오버헤드가 발생하지 않는다. 

오버헤드는 파괴할 때 발생을 하는데 파괴는 메모리가 부족하거나 cpu가 놀때 한다.



Test024변경  파라미터 넣기 생성자메소드에 파라미터 넣는 거 같이
```c

#include <stdio.h>
#include <stdlib.h>
 //두개의 변수를 묶어서 apple 이라는 이름으로 '구조체'를 정의 
int apple_add(int i,int j){
	return 100;
}
typedef struct apple{
	int i;
	int (*add)(int,int);
}Apple;

//인스턴스 생성과 유사한 동작을 하게 된다.
//이렇게 해서 생성되고, 이것을 가리키는 포인터를 톻해서
//	함수와 변수가 접근되어 질 수 있다. 
Apple* new_Apple( int j ){
	Apple* n;
	n = (Apple*)malloc( sizeof(Apple));
	n->i = j;
	n->add = apple_add;
	return n;
}
int main(){
	Apple* t; 

	t = new_Apple(100);  
	t->i = 100;
	t->add = apple_add;
	printf("%d \n", (t->i + t->add(10,20)));
	
	free(t);
	return 0;	
}
/*
	Test024.c
*/
```





### Test025.java

```java
class Banana{
    int i=0;
    int add (int i, int j){return 100;}
    /*
    리턴타입이 없고, 클래스명과 함수명이 동일하면 생성자 함수이다.
    (Constructor) - 함수라고 보기는 좀 어렵다. (포인터로 호출 x)
    인스턴스 생성 시점에 호출되고,
    주용도가 인스턴스 내부의 변수의 초기값을 줄 때 사용된다.
     */
    Banana( int j ){
    }
}

public class Test025 {
    public static void main(String[] args) {
        Banana t = new Banana(100);
        System.out.println(t.i+t.add(10,20));
    }
}

```



### 과제 아래 개념을 쓰고, 그리고, 코드로 설명

class :class는 instance의 설계도 같은 개념으로 명시(변수, 함수 선언)만 할뿐 사용할 수는 없다.

instance: class라는 설계도에서 만들어진 실체, 로봇같은 것으로 변수 대입과 함수 사용이 가능하다.  

new : class에서 instance를 만들 때 사용하는 것이다.

참조형 변수: 자료형이아닌 클래스 이름으로 생성하여 해당 클래스를 이용해 만들어진 인스턴스를 가리킬 수 있다.

자료형변수: 자바의 자료형으로 기억공간을 할당받은 변수로 정해진 자료형의 값을 저장한다.

| byte  | short | int   | long  | float | double | boolean | char  |
| ----- | ----- | ----- | ----- | ----- | ------ | ------- | ----- |
| 1byte | 2byte | 4byte | 8byte | 4byte | 8byte  | 1byte   | 1byte |

<u>정수 저장용(byte, short, int , long,)  실수 (float, double), 논리(boolean), 문자(char)</u>    

대입(i=t) 일반적으로 t를 i에 대입한다. 참조형 변수의 경우는 t가 가리키는 것을 i도 가리킨다.

멤버함수 :class 내부 선언

멤버변수 : class 내부 선언

로컬변수 : 함수 안에 선언된 변수

할당시점 : 변수 혹은 함수가 기억공간에 할당되는 시점이다.

생성자함수:함수라고 보기는 좀 어렵다. (포인터로 호출 x)
    인스턴스 생성 시점에 호출되고,
    주용도가 인스턴스 내부의 변수의 초기값을 줄 때 사용된다.

---

#### 1.class를 선언

```java
class Rabbit{

}
public class HomeWork5 {
    public static void main(String[] args) {
        
    }

}
```


#### 2.멤버변수,멤버함수 선언

```java
class Rabbit{
    int i;
    int add(int j,int k){return 100;}
}
public class HomeWork5 {
    public static void main(String[] args) {

    }
}
```

- 멤버변수-class: class 내부에 변수를 선언한다.(1)

- 멤버함수-class: class 내부에 함수를 선언한다.(2)

- 멤버함수-로컬변수 : 로컬변수는 함수 안에서 선언한다.

  +)int i,j는 매개변수이고 함수 내부의 있기 때문에 로컬변수이다.

#### 3.생성자함수

```java
class Rabbit{
    int i;
    int add(int j,int k){return 100;}

    Rabbit(int i) {
        this.i = i;
    }
}
public class HomeWork5 {
    public static void main(String[] args) {
        
    }
}
```

-  class-생성자함수: 생성자 함수는 return타입이 없이 class 이름과 같은 이름으로 만든다.
- 생성자함수-멤버함수 : 생성자 함수는 멤버함수와 달리 return타입이 없고 instance 호출시 1회만 호출된다.  

#### 4.instance 생성

```java
class Rabbit{
    int i;
    int add(int j,int k){return 100;}
    Rabbit(int i) {
        this.i = i;
    }
}
public class HomeWork5 {
    public static void main(String[] args) {
        int i= 100;
        Rabbit t = new Rabbit(i);
    }
}
```

- class - new- instance : class를 new하여 instance 생성한다. 

- 생성자함수-멤버변수 : 생성자의 매개변수가 있는 경우 그 에 맞는 값을 전달해야 하며 멤버변수의 초기값을 주는 역할을 한다.

- class -참조형변수-instance : class의 이름을 이용하여 참조형 변수 t를 선언한다. t는 Rabbit class를 이용한 instance를 가리킨다.

- 멤버변수-instance : 멤버변수는  instance가 생성될 때 생성된다.

- 자료형변수-대입(i=t)-참조형변수 : 자료형변수는 대입시 오른쪽의 값을 복사하여 왼쪽에 넣어준다. 그러나 참조형변수는 오른쪽이 가리키는 것을 왼쪽도 가르키게 된다.

- 로컬변수-할당시점-멤버변수 : 로컬변수는 함수가 호출될 때 생성이 되고 멤버변수는 인스턴스가 생성될 때 생성된다.

  

---



# Day3. 자바기초 

강사님 말씀: 업무에 맞게 짜는 것, 고객의 맞게 짜는 것, 중요한 것만 공부하고 곁가지는 문서 찾아가면서 하는 것이 좋다.(수천개 클래스를 전부 볼 수는 없으니).  

게시판 숙달 + 응용



### Test026.java 복습-class와 관계

```java
class Apple2 {
    int data = 0;

    int add(int i, int j) {
        return 100;
    }
}
//멤버변수(property) , 멤버함수(method)
//클래스로 할 수 있는 것 참조형 변수 선언, new하여 instance 생성

public class Test026 {
    public static void main(String[] args) {
        Apple2 t = new Apple2();
        int i = t.add(10, 20);
    }
}

```



### Test027.java 객체지향 언어의 3대속성 , 상속, 클래스로 할 수 있는 것 3가지 

```java
/*
    객체지향의 언어의 3대 속성
    1.상속성 : 클래슬 상속해서 클래스 만든다.
    2.은닉성 : 감추고 싶으건 감출 수 있다. 쓰지 못하게 하고 싶은 건 쓰지 못하게
    3.다형성 : 하나의 심볼(이름)이 여러 실체에 매핑될 수 있다.
 */
class A {
    int apple = 10;
}

// 클래스 B는 클래스 A를 상속하여 만들어졌음을 명시함.
//      A에서 선언한 멤버변수 멤버함수를 내려받겠다. (물려받겠다 ) ...
class B extends A {
    int add(int i, int j) {
        return 100;
    }
}

public class Test027 {
    public static void main(String[] args) {
        B t = new B();
		System.out.println(t.apple);
	}
}
/*Q 에러 안나는 이유를 설명하시오 - 
	
*/
//클래스로 할 수 있는 3가지 : 참조형 변수 선언, 인스턴스 생성 , 상속받아 클래스 선언
```

why- t,apple이 에러가 나지 않는가? 

-A라는 클래스를 선언했고 그 뒤 B가 A를 상속받아 클래스를 만들었다.
그리고 그 B클래스를 참조형변수 t가 클래스 B를 new하여 만든 instance를 가리켰기 때문에 t.apple이라는 변수에 접근이 가능하다. 또 	B가 A를 상속했기 때문에 A가 가진 멤버변수를 가진다.

### Test028.java

```java
class Apple3{
    int data = 0;
    // return 문장이 없는 함수를 서브루틴이라 한다. 리턴타입을 void 로 선언한다.
    // 멤버함수 안에서 자신이 소속된 인스턴스에 대한 포인터를 사용가능 : this (참조형 변수)
    void print(){
        System.out.println( this.data );
    }
}
    //두 개의인스턴스가 있을 때 print를 할 경우 this로 불러오는 경우 각각의 객체를 가리킨다. t의 this는 t를 l의 this는 l을
    //this는 c로 짤 경우 매개변수(로컬변수)로 짠다.
    //print메소드는 메모리에 저장이 되어있고, 포인터만이 인스턴스에만 있다. 즉 t의 print도 l의 print도 둘 다 똑같은 print코드를 가리킨다.

    //오늘 과제 : 나눠준 temp04.c 파일을 분석해서 java 와 비교해서 리포트 작성.
    //함수 하나의 길이가 크다고 해서 인스턴스를 많이 생성하면 메모리에 부담가나 ? No... Why? ->temp04.c 분석

public class Test028 {
    public static void main(String[] args) {
        Apple3 t = new Apple3();
        t.data =10;
        t.print();

        Apple3 l = new Apple3();
        l.data= 20;
        l.print();
    }
}

```



![Test028](D:\doc\메모\자바캠프\img\Test028.jpg)



### Test029.java 1.node생성 

```java
class Node{ //외워라!
    int data = 0; //  대입은 원래 불가능하나 선언과 동시에 대입은 가능함
    Node next = null; //가리키고 싶지않다.

    Node( int i , Node n){ //생성자 일반적 예시
        this.data = i;
        this.next = n;
    }
}
public class Test029 {
    public static void main(String[] args) {
        Node head = new Node(0,null); //1.
        Node tail = head;

        tail.next = new Node(10, null);//2.
        tail = tail.next;

        tail.next = new Node(20, null);//3.
        tail = tail.next;

    }
}
/*
    모든 참조형 변수에는 null 이라는 값이 대입 가능 : 가리키는 인스턴스 없다.
    -어떻게 돌아가는지 상황파악을 그림으로 설명 가능할 것.
 */
```

1.

![Test029-node01](D:\doc\메모\자바캠프\img\Test029-node01.jpg)

2.

![Test029-node02](D:\doc\메모\자바캠프\img\Test029-node02.jpg)

3.

![Test029-node03](D:\doc\메모\자바캠프\img\Test029-node03.jpg)

4.
![Test029-node04](D:\doc\메모\자바캠프\img\Test029-node04.jpg)



#### Test029.java  노드 만들어보기

```java
class Node{ //외워라!
    int data = 0; //  대입은 원래 불가능하나 선언과 동시에 대입은 가능함
    Node next = null; //가리키고 싶지않다.

    Node( int i , Node n){ //생성자 일반적 예시
        this.data = i;
        this.next = n;
    }
}
public class Test029 {
    public static void main(String[] args) {
        Node head = new Node(0,null);
        Node tail = head;

        tail.next = new Node(10, null);
        tail = tail.next;

        tail.next = new Node(20, null);
        tail = tail.next;
        System.out.println(head.next);//Node@4554617c 신기.....
        for( Node t =head.next ; t !=null ; t=t.next){
            System.out.println(t.data);  //10 \n 20 \n
        }
    }
}
/*
    모든 참조형 변수에는 null 이라는 값이 대입 가능 : 가리키는 인스턴스 없다.
    -어떻게 돌아가는지 상황파악을 그림으로 설명 가능할 것.
 */
```

5.

![Test029-node05](D:\doc\메모\자바캠프\img\Test029-node05.jpg)

6.

![Test029-node06](D:\doc\메모\자바캠프\img\Test029-node06.jpg)

7.

![Test029-node07](D:\doc\메모\자바캠프\img\Test029-node07.jpg)

8.

![Test029-node08](D:\doc\메모\자바캠프\img\Test029-node08.jpg)

6~8반복



#### Test029.java 메인에 있던 링크드 리스트를 링크드리스트 클래스로 옮김

```java
class Node { //외워라!
    int data = 0; //  대입은 원래 불가능하나 선언과 동시에 대입은 가능함
    Node next = null; //가리키고 싶지않다.

    Node(int i, Node n) { //생성자 일반적 예시
        this.data = i;
        this.next = n;
    }
}

class LinkedList {
    Node head = null;
    Node tail = null;

    public LinkedList() {
        this.head = new Node(0, null);
        this.tail = this.head;
    }

    void add(int i) {
        tail.next = new Node(i, null);
        tail = tail.next;
    }
}

public class Test029 {
    public static void main(String[] args) {
        LinkedList l = new LinkedList();
        l.add(10);
        l.add(20);

    }
}
/*
    모든 참조형 변수에는 null 이라는 값이 대입 가능 : 가리키는 인스턴스 없다.
    -어떻게 돌아가는지 상황파악을 그림으로 설명 가능할 것.
 */
```



#### Test029.java 변경 print추가

```java
class Node { //외워라!
    int data = 0; //  대입은 원래 불가능하나 선언과 동시에 대입은 가능함
    Node next = null; //가리키고 싶지않다.

    Node(int i, Node n) { //생성자 일반적 예시
        this.data = i;
        this.next = n;
    }
}

class LinkedList {
    Node head = null;
    Node tail = null;

    public LinkedList() {
        this.head = new Node(0, null);
        this.tail = this.head;
    }

    void add(int i) {
        tail.next = new Node(i, null);
        tail = tail.next;
    }

    public void print() {
        for (Node n= head.next; n != null  ; n = n.next) {
            System.out.println(n.data);
        }
    }
}

public class Test029 {
    public static void main(String[] args) {
        LinkedList l = new LinkedList();
        l.add(10);
        l.add(20);
        l.print();
    }
}
/*
    모든 참조형 변수에는 null 이라는 값이 대입 가능 : 가리키는 인스턴스 없다.
    -어떻게 돌아가는지 상황파악을 그림으로 설명 가능할 것.
 */
```



### Test030.java 상속 조상클래스 자손클래스 관계



```java
class A1{
    A1(){System.out.println("A constructor");}

}

class B1 extends A{
    B1(){System.out.println("B constructor");}

}

public class Test030{
    public static void main( String[] args ) {
        new B1(); //A생성자가 먼저 호출되고 B의 생성자가 호출된다.
    }
}
/* -상속 관계가 존재할 때 ( 조상클래스 , 자손클래스) 자손의 인스턴스를 생성하면 
	조상의 생성자가 먼저 호출되고, 자손의 생성자가 호출된다.

    -생성자는 상속되지 않는다. 다만 호출될 뿐이다. 맴버함수도 아니다.
     (참조형 변수로 호출할 수 없다.)

     인스턴스 B를 만들때 생성자가 두 번 호출되는 것이지(A생성자 B생성자) 인스턴스가 두개 만들어지는 것이 아니다.

*/
```

###  ![Test030-01](D:\doc\메모\자바캠프\img\Test030-01.jpg)

-생성자는 멤버함수가 아니다. 따라서 참조형변수로 호출불가능



### Test031.java  오버라이딩

```java
class A2{
    void print(){ System.out.println("A print");}
}
class B2 extends A2{
    void print(){

        System.out.println( "B print");
        //물려받은 자손쪽에서 물려받은 함수를 호출하고 싶을 때 super 를 이용한다.
        super.print();
    }
}
public class Test031 {
    public static void main(String[] args) {
        B2 t = new B2();
        t.print();
        A2 t2 = new A2();
        t2.print();
    }
}
/*
    method overridding : 조상에서 선언한 멤버함수를 자손에서 다시 선언할 수 있다.
    : 자손의 인스턴스의 print 를 호출되면 (조상? 자손? ) 자손
    
    상속? 생성자? 영향있다. 
    자손에서 물려받은 함수 재선언? 된다.
    조상의 메소드와 같은 이름으로 자손쪽에서 메소드 선언가능
    자손인스턴스로 동명 메소드는 자손의 메소드가 호출된다,
    조상에서 선언된 함수는 못 쓰나?
    이 경우 조상 클래스의 메소드를 사용하고 싶다면 super 를 이용하면된다.
 */
```

### temp04.c
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct apple {
	int data;
	void (*print)( void* );
}Apple;

typedef struct pine_apple {
	int data;  //상속이란 개념이 없기 때문에 조상의 변수를 여기서 선언해줌. 
	void (*print)( void* );

	float pi;
	int (*increase)( void* , int i );
}PineApple;

void apple_constructor( void* self , int data ) 
{
	Apple* this = (Apple*)self;
	this->data  = data;
}

void pine_apple_constructor( void* self , int data ) 
{
	PineApple* this = (PineApple*)self;
	this->pi = 3.14;
}

void apple_print( void* self )
{
	Apple* this = (Apple*)self;
	printf("Apple %d\n" , this->data );
}

void pine_apple_print( void* self )
{
	PineApple* this = (PineApple*)self;
	printf("PineApple %d : %f\n", this->data, this->pi );
}

int pine_apple_increase( void* self, int i )
{
	PineApple* this = (PineApple*)self;
	printf("%f\n", this-> pi );
	
	return ( this->data + i );
}

Apple* new_Apple( int data ){
	Apple* new;
	new = (Apple*)malloc( sizeof(Apple) );
	
	new->print = apple_print;
	
	apple_constructor( new, data );
	
	return new;
}

PineApple* new_PineApple( int data ){
	PineApple* new;
	new = (PineApple*)malloc( sizeof(PineApple) );
	
	new->print = apple_print;
	
	new->increase = pine_apple_increase;
	new->print = pine_apple_print;
	
	apple_constructor( new, data );
	pine_apple_constructor( new, data );
	
	return new;
}

int main()
{
	Apple* t;
	
	t = (Apple*)new_PineApple( 100 );
	t->print( t );
	
	free( t );
	
	return 0;
}
```

### Test032.java 상속 A t = new B();

1.

```java
class A3{
    int i =100;
    void print(){
        System.out.println("A print");
    }
}
class B3 extends A3{
    void print2(){
        System.out.println("B print2");
    }
}
public class Test032 {
    public static void main(String[] args) {
        A3 t =new B3();
        t.print(); //A print
//        t.print2(); 
    }
}
/*
    조상타입의 변수로 자손의 인스턴스를 가리킬 수 있다.
        조상에서 선언된 멤버함수 멤버변수만 호출이 가능하다.
        -B의 인스턴스 안에 print2 는 존재한다. 하지만 호출할 수 업다.
 */

```

2.

```java
class A3{
    int i =100;
    void print(){
        System.out.println("A print");
    }
}
class B3 extends A3{
    void print2(){
        System.out.println("B print2");

    }
    void print(){
        System.out.println("B print");
    }
}
public class Test032 {
    public static void main(String[] args) {
        A3 t =new B3();
        t.print();
//        t.print2();
    }
}
/*
    조상타입의 변수로 자손의 인스턴스를 가리킬 수 있다.
        조상에서 선언된 멤버함수 멤버변수만 호출이 가능하다.
        -B의 인스턴스 안에 print2 는 존재한다. 하지만 호출할 수 업다.
    만일 오버라이딩 된 함수를 호출된다면 이때는 오버라이딩 된 것이 호출된다.
 */

```

  A3 t =new B3(); 어떨 때 사용할까?

3.

```java
class A3{
    int i =100;
    void print(){
        System.out.println("A print");
    }
}
class B3 extends A3{
    int i = 200;
    void print2(){
        System.out.println("B print2");

    }
    void print(){
        System.out.println("B print");
    }
}
public class Test032 {
    public static void main(String[] args) {
        A3 t =new B3();
        t.print();
        System.out.println(t.i); //100 조상클래스의 멤버변수가 호출
//        t.print2();
    }
}
/*
    조상타입의 변수로 자손의 인스턴스를 가리킬 수 있다.
        조상에서 선언된 멤버함수 멤버변수만 호출이 가능하다.
        -B의 인스턴스 안에 print2 는 존재한다. 하지만 호출할 수 업다.
    만일 오버라이딩 된 함수를 호출한다면 이때는 오버라이딩 된 것이 호출된다.

    왜 100이 나오는 지 그 이유를 정리하자. -멤버변수에는 오버라이딩 개념이 없다. 따라서 조상타입의 참조형변수는조상클래서멤버변수를 가져온다.
    
 */

```

(내생각: 참조형 )

### Test033.java 접근제어

private -상속 x 외부노출x 내가쓰는것o 마약

protected - 상속o 외부노출x 내가쓰는것o 모나리자

public -	상속o외부노출o 내가쓰는것o 별장

클래스 안에 멤버변수, 멤버함수의 앞에 붙여준다. =>감추고 싶은 것 감추자.<은닉성>        *로컬변수x

이 세개는 C++에서도 있다

java의 protected 는  1. 같은패키지에서는 접근 가능

​								 2. 다른 패키지에서는 접근 불가능

(적지 않은 경우는) friendly 같은 패키지안에서는 public하게 동작하고 

​						                    다른 패키지에서는 private하게 동작

실전은 private 이나 public만 쓴다.



#### private

```java
class A4{
    private int mayak = 0;
    protected int monarisa = 0;
    public int house2 = 0;
}
class B4 extends A4{
    void print(){
        System.out.println(mayak);
    }
}
public class Test033 {
    public static void main(String[] args) {
        A4 look = new A4();
        System.out.println(look.mayak);
    }
}

```



#### protected

```java
class A4{
    private int mayak = 0;
    protected int monarisa = 0;
    public int house2 = 0;
}
class B4 extends A4{
    void print(){
        System.out.println(monarisa);
    }
}
public class Test033 {
    public static void main(String[] args) {
        A4 look = new A4();
        System.out.println(look.monarisa);//자바에서는 되나 c++에서는 안된다, 자바는 같은 패키지 안에서는 접근 가능
    }
}
/*
    look.monarisa 은 같은 패키지에서는 접근 가능. 다른 팩키지에서는 접근 불가.
    protected를 포수의 사인으로 이해하면 좋다.
    같은 팀의 다른 클래스에게는 알려지지만, 다른 팀에 소속된 클래스는 접근 불가해야 한다.
    후배에게 물려줄 때는 접근 가능해야 한다.
 */

```



#### public

```java
class A4{
    private int mayak = 0;
    protected int monarisa = 0;
    public int house2 = 0;
}
class B4 extends A4{
    void print(){
        System.out.println(house2);
    }
}
public class Test033 {
    public static void main(String[] args) {
        A4 look = new A4();
        System.out.println(look.house2);
    }
}
/*
    look.monarisa 은 같은 패키지에서는 접근 가능. 다른 팩키지에서는 접근 불가.
    protected를 포수의 사인으로 이해하면 좋다.
    같은 팀의 다른 클래스에게는 알려지지만, 다른 팀에 소속된 클래스는 접근 불가해야 한다.
    후배에게 물려줄 때는 접근 가능해야 한다.
    
    (실전에서는 private / public 많이 쓴다.)
 */

```





### Test034.java


```java
class A5{
    private int data = 100;

    public int getData(){return data;}
}
class B5 extends A5{
    private int data = 200;

    @Override
    public int getData() {
        return data;
    }
}
public class Test034 {
    public static void main(String[] args) {
        A5 t = new B5();
//        System.out.println(t.data);
        System.out.println(t.getData()); //자손의 data 가 출력된다.
    }
}
/*
    멤버변수는 무조건 private 하게 선언한다,
    값을 읽고자 할 때는 getter 함수를 이용하여 접근한다.
    -A t = new B() 에서 t.i 는 조상의 값, t.print() 는 오버라이딩 된 게 나오고...
    이런 일이 벌어지지 않게 되더라 ...
    에티켓
    *조상에서 getXXX 가 보이걸랑 그런 변수가 있는 줄 알고 xXX 변수는 피해간다.
     만약 조상클래스의 getData를 써서 조상data를 가져오려고 하면 겹치게된다.(super를 써도 되지만 하지말자) 
 */

```



### Test035.java

```java
abstract class A6 { //abstract 메소드를 하나라도 가진다면 클래스 또한 abstract를 가져야한다.
    abstract public  void print();
}
abstract class B6 extends D6 { //abstract 메소드가 없더라도 abstract가 클래스에 붙어도 상관없다. abstract class 도 상속을 받을 수 있다.

}
class C6 extends B6{ //abstract class 를 상속받아 클래스를 만들수 있다.
}
class D6 {}
public class Test035 {
    public static void main(String[] args) {
        //new B6(); 추상 클래스는 인스턴스 생성불가
        A t = null; //참조형변수 선언가능
    }
}
/* 위의 print 함수는 선언되었지만 정의되지 않았다. 반드시 abstract 붙여준다.
	abstract 메소드를 하나라도 가진 클래스는 abstract 클래스라고 정의해야 한다.
	클래스는 3가지 인스턴스 생성 변수선언 상속이 가능하나,
	abstract class 는 인스턴스를 못 만든다. 변수선언, 상속은 가능하다
*/



```

![Test035](D:\doc\메모\자바캠프\img\Test035.jpg)

Test036.java

```java
abstract class A7{
    abstract public void print();
}
class B7 extends A7{
    public void print(){
        System.out.print(100);
    }
}
public class Test036 {
    public static void main(String[] args) {
        A7 t = new B7();
        t.print();
    }
}
/*
    abstract 메소드를 오버라이딩 하면 abstract 성질이 없어지게 된다.
    A t ? 가능 new B()? 가능  A t =  new B() ? 가능  t.print() ? 가능 오버라이딩된게 호출
    1.추상화클래스도 변수생성가능
    2.클래스는 인스턴스 생성가능
    3.조상클래스의 참조형변수는 자손의 인스턴스를 가리킬 수 있다.
    4.조상클래스의 참조형변수는 조상클래스의 정의된 메소드를 호출할 수 있다. 그리고 자손클래스가 오버라이딩한경우에는 오버라이딩된 메소드를 호출한다.
 */

```



오버라이딩1.A t= new B(); A의 생성자부터

![Test036-01](D:\doc\메모\자바캠프\img\Test036-01.jpg)



오버라이딩2. B의 생성자 생성 가리키는걸 바꿔줌 

![Test036-02오버라이딩](D:\doc\메모\자바캠프\img\Test036-02오버라이딩.jpg)



![Test036-03](D:\doc\메모\자바캠프\img\Test036-03.jpg)

A t의 경우 A클래스의 참조형 변수이므로 B인스턴스의 A부분만을 가리킬 수 있다. A가 print를 가지고 있기 때문에

print 를 호출할 수 있다. 그렇지만 B가 오버라이딩 했기때문에 A가 가리키는 것이 A의 print가 아닌 B의 print를 호출하게된다.





abstract는 함수포인터가 null인경우임

그렇기 때문에 인스턴스를 만들 수 있다면 추상메소드를 호출하면 정의되지 않았기 때문에 에러가 나오기 때문에

인스턴스 생성불가



### Test037.java

```java
abstract class Bank {
    abstract public double calc(double money, int years,double rate);
    public void print(){
        double r =calc(100, 100, 0.66);
        System.out.println(r);
    }
}

class BokriBank extends Bank{
    @Override
    public double calc(double money, int years, double rate) {
        return 59665.1234;
    }
}

public class Test037 {
    public static void main(String[] args) {
        Bank bk = new BokriBank();
        bk.print();
    }
}

```

이 때 단리로 바꿔라

```java
abstract class Bank {
    abstract public double calc(double money, int years,double rate);
    public void print(){
        double r =calc(100, 100, 0.66);
        System.out.println(r);
    }
}

class BokriBank extends Bank{
    @Override
    public double calc(double money, int years, double rate) {
        return 59665.1234;
    }
}
class DanriBank extends Bank{

    @Override
    public double calc(double money, int years, double rate) {
        return 760.0;
    }
}

public class Test037 {
    public static void main(String[] args) {
        Bank bk = new DanriBank();
        bk.print();

    }
}

```

상속하여 추상화 된 부분만을 만들어 인스턴스만 교체해주면된다.

자주바뀌는 것 유지보수시 도움됨

템플릿 메서드 패턴이란
어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
https://gmlwjd9405.github.io/2018/07/13/template-method-pattern.html



```java
abstract class Bank {
    abstract public double calc(double money, int years,double rate);
    public void print(){
        double r =calc(100, 100, 0.66);
        System.out.println(r);
    }
}

class BokriBank extends Bank{
    @Override
    public double calc(double money, int years, double rate) {
        return 59665.1234*subCalc();
    }
    private int subCalc(){return 1;} //서브로 계산을 해야줘야했다 가정
}
class DanriBank extends Bank{

    @Override
    public double calc(double money, int years, double rate) {
        return 760.0+money();
    }

    private int money(){return  100;}
}

public class Test037 {
    public static void main(String[] args) {
        Bank bk = new DanriBank();
        bk.print();

    }
}

```

c에서는 서브루틴이나 처리하는 함수가 있었을 때 그 함수를 같이 바꿔줘야하는데 클래스만 바꿔주면 된다.?

전략패턴

### Test038.java

```java
interface ICalc { //interface 언에는 전부 abstract여야함. 인터페이스도 일종의 abstract클래스이다.
    public void print();
}

interface IUnknown{}
class Apple5{}
class Calc extends Apple5 implements ICalc, IUnknown{//인터페이스를 상속해서 클래스를 선언할 때에는 implements를 이용해야 한다.
    public void print() {
        System.out.println("A");
    }

}
public class Test038 {
    public static void main(String[] args) {
        ICalc ic =new Calc();
        ic.print();
    }
}
/*
    인터페이스에 선언된 method는 몽땅 abstract 해야 한다.
    인터페이스를 상속해서 클래스를 선언할 때에는 implements를 이용해야 한다.
    상속받은 클래스는 인터페이스에 선언된 메소드를 몽땅 오버라이딩 해야 한다.
    인터페이스는 일종의 abstract 클래스이다. -변수선언(정의까지), 상속당함 가능, 인스턴스생성불가
    2개 이상의 인터페이스 상속 OK, 동시에 클래스 1개 상속? OK
 */
```



### Test039.java

```java
interface IGreet {
    public String greet();
}

class MerciGreet implements IGreet {
    public String greet() { return "Merci"; }
}

class HelloGreet implements IGreet {
    public String greet() { return "Hello"; }
}

public class Test039 {
    public static void main(String[] args) {
        IGreet ig = new MerciGreet();
        System.out.println(ig.greet());
    }
}

```





| ㅁ                                                           | ㅁ                                                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| typedef struct apple {<br/>	int data;<br/>	void (*print)( void* );<br/>}Apple; | class Apple{   <br /> int data;   <br /> public Apple(int data) {<br />        this.data = data;    } |





---



# Day4. 자바기초

---



Object  -class 추상명사느낌

​			-instance 실체

이 둘이 혼용되어 오브젝트로 쓰이기도한다. 익명클래스 javascript 등



### Test040.java 오버로딩

```java
class Temp{
    public void print(){
        System.out.println(1);
    }
    public void print( int i ){
        System.out.println(i);
    }
    public void print( double i){
        System.out.println(i);
    }
    public void print( int i , int j){
        System.out.println("i: "+i+" j: "+j);
    }

}
/*
    하나의 클래스 안에 이름은 같은데 매개변수 형태가 틀린 함수가 여러개 공존가능
    -method overloading
    
    딱 매개변수가 맞지 않으면 가장 가깝게 자동 형변환 되는 것을 찾아서 호출한다.
 */
public class Test040 {
    public static void main(String[] args) {
        Temp t = new Temp();
        t.print();

        //float j = (float) 3.14; //실수형의 대표 double 정수형의 대표는 int 이다. 따라서 double 이 float 에 대입되는 것이기 때문에 큰 자료형에서 작은 자료형으로 대입이므로 오류가 난다.
        //float j =  3.14;// 방법1.강제형변환을 해야한다.
        float j = 3.14F; //방법2. 더 좋은 방법
        t.print( j ); //자료형이 딱 맞지 않아도 상관이 없다. 가장 쉽게 가깝게 자동형변환 되는 것으로 
    }
}

```



### Test041.java 자손에서 조상클래스의 변수 이름을 사용하지말자

```java
class A8{
    int i= 100;
}
class B8 extends A8{
    int i = 200;
    public void print(){
        System.out.println(i);
    }
}
public class Test041 {
    public static void main(String[] args) {
        A8 t = new B8();
        System.out.println( t.i); //A의 i
//        t.print(); 안됨
        // t 포인터가 가리키는 인스턴스를 감싸는 B 클래스 인스턴스를 t2가 가리킨다.
        B8 t2 = (B8)t;
        System.out.println( t2.i); //B의 i가 나온다. 캐스팅을 하면 값이 달라지기 때문에 조상에서 사용한 변수는 사용하지 않는 것이 좋다.
        t2.print();
        System.out.println(t2.i);
    }
}

```



### Test042.java Static

```java
class Temp2{
    static int i = 100;
}
 public class Test042 {
     public static void main(String[] args) {
         int j = Temp2.i;
     }//java 는 컴파일하면 같은 파일안에 class 가 있어도 클래스별로 파일을 나눠준다.
 }
//static 한 변수는 class 가 메모리 올라올 때 메모리 할당을 받아 생성된다.
 //실행순서 main 메소드를 포함한 class 가 메모리로 와서 실행 추후 필요한 class 를 불러온다.
/*
    자바 실행환경은 클래스가 필요해지면 .class 파일을 메모리에 올린다.
        그 후에 인스턴스 생성이 가능하다.

    static 멤버는 클래스 로딩시에 메모리에 할당받는다. 무조건 유일하다. +클래스는 최초에 한번만 올라간다. ->그렇기 때문에 static 멤버는 1개만 존재한다.
            (인스턴스가 몇개이건 간에)
    non-static 멤버는 인스턴스가 생성될 때 할당되고 인스턴스마다 따로따로 존재.
 */

```



### Test043.java static 2

```java
class Temp3{
    int i = 100;
    static void print(){
        System.out.println(i);
    }
}
public class Test043 {
    public static void main(String[] args) {
        Temp3.print();
    }
}
/*
    static 멤버는 클래스명.심볼 형태로 접근.(인스턴스 생성전에 존재)
    static 멤버 함수 안에서는 non-static 한 멤버함수 멤버변수에
        접근할 수 없다 . (위의 i 의 경우 ) - 왜? static 멤버 함수인 print가 메모리에 올라오면서 할당되고 i는 non-static 멤버이기 때문에 인스턴스가 생성되기 전이라 오류가난다.
 */

```





### 지금까지 개념

자료형변수_대입 참조형변수_대입

class instance 로컬변수 멤버변수 참조형 변수 자료형 변수 생성자함수

...

extends implements interface abstract_class abstract_method 

overridding overloading 자료형변수_캐스팅 참조형변수_캐스팅  

private public protected (friendly) (A t =new B() )

이런 것들이 자연스럽게 설명하고 코드가 나올 정도까지







class  명세를 하는 것으로 instance의 설계도이다. 클래스는 멤버함수와 변수 선언, 인스턴스 생성,상속하여 클래스를 선언할 수 있다. 

instance 클래스의 실체로 클래스를 new를 하여 인스턴스가 생성된다. 생성시 로컬변수들이 생성된다.

로컬변수 메소드 안에 있는 변수로 함수가 호출 될 때 메모리할당을 받는다.

멤버변수 클래스 안에 있는 변수로 인스턴스가 생성될 때 메모리를 할당받는다.

참조형 변수 클래스의 이름으로 선언한 변수로 일종의 포인터변수이다. 같은 클래스 혹은 자손의 인스턴스를 가리킨다.  

자료형변수: 자바의 자료형으로 기억공간을 할당받은 변수로 정해진 자료형의 값을 저장한다.

| byte  | short | int   | long  | float | double | boolean | char  |
| ----- | ----- | ----- | ----- | ----- | ------ | ------- | ----- |
| 1byte | 2byte | 4byte | 8byte | 4byte | 8byte  | 1byte   | 1byte |

<u>정수 저장용(byte, short, int , long,)  실수 (float, double), 논리(boolean), 문자(char)</u>    

자료형변수_대입:오른쪽의 값이 왼쪽에 복사 대입

참조형변수_대입:  오른쪽이 가리키는 대상을 왼쪽이 가리키게 된다.

생성자함수 : 리턴타입이 없고, 클래스명과 함수명이 동일하다. 

​    함수라고 보기는 좀 어렵다. (포인터로 호출 x)
​    인스턴스 생성 시점에 호출되고 주용도가 인스턴스 내부의 변수의 초기값을 줄 때 사용된다.

...

extends  :조상에서 선언한 멤버변수 멤버함수를 자손으로 내려받겠다. 물려받은 것은 자손 인스턴스에서 사용할 수 있다.

상속 관계가 존재할 때 ( 조상클래스 , 자손클래스) 자손의 인스턴스를 생성하면 
	조상의 생성자가 먼저 호출되고, 자손의 생성자가 호출된다.

-생성자는 상속되지 않는다. 다만 호출될 뿐이다. 맴버함수도 아니다.

 (참조형 변수로 호출할 수 없다.)

 인스턴스 B를 만들때 생성자가 두 번 호출되는 것이지(A생성자 B생성자) 인스턴스가 두개 만들어지는 것이 아니다.

implements 인터페이스를 상속해서 클래스를 선언할 때 이용한다.

interface 인터페이스에 선언된 method는 몽땅 abstract 해야 한다.
    인터페이스를 상속해서 클래스를 선언할 때에는 implements를 이용해야 한다.
    상속받은 클래스는 인터페이스에 선언된 메소드를 몽땅 오버라이딩 해야 한다.
    인터페이스는 일종의 abstract 클래스이다. -변수선언(정의까지), 상속당함 가능, 인스턴스생성불가
    2개 이상의 인터페이스 상속 OK, 동시에 클래스 1개 상속? OK

abstract class : 추상 클래스는 참조형변수 선언가능하지만 인스턴스 생성불가
abstract 메소드를 하나라도 가진다면 클래스 또한 abstract를 가져야한다.
abstract 메소드가 없더라도 abstract가 클래스에 붙어도 상관없다. abstract class 도 상속을 받을 수 있다.
abstract class 를 상속받아 클래스를 만들수 있다.
abstract class 는 인스턴스를 못 만든다. 변수선언, 상속은 가능하다

abstract_method : abstract 메소드를 오버라이딩 하면 abstract 성질이 없어지게 된다.

overridding  조상에서 선언한 멤버함수를 자손에서 다시 선언할 수 있다.

overloading 하나의 클래스 안에 이름은 같은데 매개변수 형태가 틀린 함수가 여러개 공존가능,딱 매개변수가 맞지 않으면 가장 가깝게 자동 형변환 되는 것을 찾아서 호출한다.

자료형변수_캐스팅 : 작은 자료형에서 큰 자료형으로는 자동으로 되고 큰 것에서 작은 것으로는 강제형변환을 해줘야한다. (큰자료형이름)작은자료형값 꼴로 사용한다.

참조형변수_캐스팅  : 자손 인스턴스를 담고 있는 조상의 참조형변수가 자손의 참조형변수에 대입할 때 

​									자손의 참조형변수가 조상의 참조형 변수가 가리키는 인스턴스를 가리키지 못하므로 캐스팅을 하									게된다.

![Test051](D:\doc\메모\자바캠프\img\Test051.jpg)



private -상속 x 외부노출x 내가쓰는것o 마약

protected - 상속o 외부노출x 내가쓰는것o 모나리자

public -	상속o외부노출o 내가쓰는것o 별장

클래스 안에 멤버변수, 멤버함수의 앞에 붙여준다. =>감추고 싶은 것 감추자.<은닉성>        *로컬변수x

이 세개는 C++에서도 있다

java의 protected 는  1. 같은패키지에서는 접근 가능

​								 2. 다른 패키지에서는 접근 불가능

(적지 않은 경우는) friendly 같은 패키지안에서는 public하게 동작하고 

​						                    다른 패키지에서는 private하게 동작

(friendly 같은패키지에서는 public 다른 패키지에서는 private)

(A t =new B() ) A t ? -클래스로 참조형변수선언 가능 ,new B()? 클래스로 new해서 인스턴스 생성가능  A t =  new B() ?  조상의 참조형변수가 자손인스턴스 가리키기 가능  t.print() ? 가능 오버라이딩된게 호출



### 인터페이스의 중요성

---

원래 코드는 쓰임당하는 코드가 만들어지고 쓰는 코드가 만들어져야하는데

인터페이스만 만들고 쓰는코드부터 만들 수가 있게 한 것  ex 플러그인 안드로이드도 이 형태

---





### Test044.java  

```java

public class Test044 {
    public static void main(String[] args) throws Exception {
        Class<?> clas = Class.forName("HelloGreet");
    }
}

```

인터페이스활용 보여주신부분

### Test045.java  자바의 배열

```java
public class Test045 {
    public static void main(String[] args) {
        int[] i = new int[]{1,2,3,4}; //자바에서는 new 를 했기 때문에  배열은 인스턴스이고 i는 참조형 변수이다.
        int[] k ={1,2,3,4};   //이것도 가능 초창기는 안됐음.
        System.out.println(i[0]);
        System.out.println(i[1]);
        System.out.println(i[2]);
        System.out.println(i[3]);
        System.out.println(i.length);

        // 이 코드는 외운다.
        for (int j = 0; j < i.length; j++) {
            System.out.println( i[j] );
        } //itar
        

    }
}
/*배열 : 동일한 형태의 기억장소가 연속으로 할당된 기억공간.
       자바의 배열은 인스턴스다. i는 참조형변수다.
       i.length 는 배열의 멤버변수이고 길이를 의미한다.

  int[] j ={1,2,3,4};   //이것도 가능  헌데 이건 new int[] 가 생략된 형태.
 */

```



### Test046.java break, continue

```java
public class Test046 {
    public static void main(String[] args) {
        int[] i =new int[]{1,2,3,4};

        for (int j = 0; j < i.length; j++) {
            if (j == 2) {
                continue;
            }
            System.out.println(i[j]);

        }
    }
}
/*
    break : 반복문을 탈출한다.
    continue : 반복문의 아래 코드는 수행을 건너뛰고 반복을 계속한다.
 */

```



### Test047.java 최고수 구하기

```java
public class Test047 {
    public static void main(String[] args) {
        int[] i = new int[]{4, 9, 6, 5};
        int max = i[0];
        for (int k = 0; k < i.length; k++) {
            if (max < i[k]) {
                max = i[k];
            }
        }
        System.out.println(max);

        
//        boolean a = Long.MAX_VALUE < Float.MAX_VALUE;
//        float b = Long.MAX_VALUE;
//        float e = (float) Long.MAX_VALUE;
//        float f = e - 1;
//        long d = (long) e;
//        long g = (long) f;
//        boolean c = Long.MAX_VALUE == d;
//        System.out.println(b + "==" + Long.MAX_VALUE + "?");
//        System.out.println(a + "" + c);
//        System.out.println(d);
//        System.out.println(g);
//        System.out.println(e);
    }
}


```





### Test048.java Object

```java
class Temp4{

}
/*
    조상클래스를 지정하지 않으면 Object 로 부터 상속받는다.
    java 에서는 기본적으로 제공되는 클래스들이 많은데 ...
        java.lang 패키지에 소속된 클래스는 import 없이 사용가능하다.
        (가장 기본적인 클래스 모음 , 막 가져다 써도 된단 얘기)

    toString() 은 Object 에 선언되었고 , 상속되었다. 알 수 있는 이유 Temp4에 선언하지도 않은 메소드가 호출가능 상속받은 Object에 있을것
    Temp4@4554617c : 클래스명@해시코드값 (인스턴스가 다르면 숫자값 다름)
    
    - Object 는 모든 클래스의 조상이 된다? Yes 
    - Object 형 변수는 어떤 인스턴스라도 가리킬 수 있다? Yes
 */
public class Test048 {
    public static void main(String[] args) {
        Object t = new Temp4();
        System.out.println( t.toString() );
        Object t1 = new Temp4();
        System.out.println( t1.toString() );
        Object t2 = new Temp4();
        Object t3 = new Temp4();
    }
}

```





### Test049.java getter, setter

```java
class Temp5 {
    private int data = 100;

    public int getData() {
        return data;
    }
    public void setData(int i){
        data =i;
    }
}

public class Test049 {
    public static void main(String[] args) {
        Temp5 t = new Temp5();
        t.setData(200);
        System.out.println(t.getData());

    }
}
/*
    멤버변수는 private 권장. 값을 읽을 때는 getter 함수를 제작해 쓴다.
    인스턴스 내의 변수 값을 읽기전용으로 하려면 ? getter 만 만들어 준다.
    인스턴스 내의 변수값을 바구고 싶을 때는 setter 를 쓰는것이 예의!
 */


```



### Test050.java String

```java
class Temp6{
    private Object data = null;

    public Object getData() { return data; }

    public void setData(Object data) { this.data = data; }
}

/*
    String : new 없이 ""로 인스턴스가 생성이 가능한 클래스
    참조형 변수의 비교는 동일한 인스턴스를 가리킬 때 true ( 동일한 null 도 true)

    l== t 이 true 가 나온다? l 과 t는 동일한 인스턴스를 가리킨다.
    StringPool 이라는 독특한 java의 구조가 나온다..

    ""를 만나면 VM 운 Stringpool 을 뒤져서 없으면 만들고, 있으면 재활용
    -웹 프로그래밍에 매우 유용하다. HTML 내용을  Srtring 으로 만들고
        재활용하는 쪽이 메모리 관리에 유용허다

 */
public class Test050 {
    public static void main(String[] args) {
        String l = "Helloworld";  //참조형변수임 이유 기본자료형 8개 안에 없었다.
        String t = "Helloworld";  //참조형변수임 이유 기본자료형 8개 안에 없었다.

        System.out.println(l==t);  //인스턴스 비교시 같은 인스턴스이어야 true

        Object o = "HelloWorld";
        String r =  (String)o;  //이런거 시험에 나옴

    }
}

```



### Test051.java Object =String

```java
class Temp7 {
    private Object data = null;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }
}

class Temp8{
    private String  data = null;

    public String getData() {
        return data;
    }

    public void setData(String data) {
        this.data = data;
    }
}
//아래 코드에서 캐스팅이 필요한 경우와 필요하지 않은 경우를 구분한다.
// 모든 인스턴스를 저장 가능한 것은 ? Temp7 캐스팅 없이 꺼낼 수 있는 것은? Temp8
public class Test051 {
    public static void main(String[] args) {
        Temp8 t2 = new Temp8();
        t2.setData("HelloWorld");
        String l2 = t2.getData();

        Temp7 t = new Temp7();
        t.setData("HelloWorld");
        String l  = (String) t.getData();
    }
}
//1. t2는 같은형이기 때문에 필요없고  t는

```



### Test052.java 제너릭

```java
class Temp9<T extends Object>{
    private T data = null;
    public T getData(){ return  data;}
    public void setData(T i ){data = i;}
}
/*
    인스턴스의 자료형을 동적으로 결정할 수 있다. : 제너릭의 개념
    1.5 버젼부터 지원되었다.

    <> 안에 지정 간으한 타입은 참조형변수 타입이어야 한다.(자료형 안됨)
    : C++의 템플레이트 ... 가 이거랑 같다. C++ 은 자료형도 <> 안에 허용
 */
public class Test052 {
    public static void main( String[] args){
        Temp9<String> t = new Temp9<String>();
        t.setData("HelloWorld");
        String l = t.getData();
    }
}

```



### Test053.java

```java
class Node3 <T extends Object>{
    T data = null;
    Node3 next = null;

    Node3(T i , Node3 n){
        data = i;
        next = n ;
    }
}
/*
    오늘의 과제 : LinkedKist 클래스를 만들되 제너릭을 써서 만들 것.
    class LinkedList <X extends Object>{
    add
    print
    }
 */
class LinkedList3<X extends Object>{
    Node3 head = null;
    Node3 tail = null;
    public LinkedList3() {
        head = new Node3(0, null);
        tail = head;
    }

    public void add(X i){
        tail.next = new Node3(i,null);
        tail = tail.next;
    }
    public void print(){
        for (Node3 n = head; n != null ; n=n.next) {

        }
        System.out.println();
    }
}

public class Test053 {
    public static void main(String[] args) {
        Node3<String> head = new Node3<String>(null, null);
        Node3<String> tail = head;

        tail.next = new Node3<String>("apple",null);
        tail = tail.next;
        tail.next = new Node3<String>("apple",null);
        tail = tail.next;
        tail.next = new Node3<String>("apple",null);
        tail = tail.next;

    }
}

```



```java
class Node3 <T extends Object>{
    T data = null;
    Node3 next = null;

    Node3(T i , Node3<T> n){
        data = i;
        next = n ;
    }
}
/*
    오늘의 과제 : LinkedKist 클래스를 만들되 제너릭을 써서 만들 것.
    class LinkedList <X extends Object>{
    add
    print
    }
 */
class LinkedList3<X extends Object>{
    Node3<X> head = null;
    Node3<X> tail = null;
    public LinkedList3() {
        head = new Node3<X>(null, null);
        tail = head;
    }

    public LinkedList3 add(X i){
        tail.next = new Node3<X>(i,null);
        tail = tail.next;
        return this;
    }
    public void print(){
        for (Node3<X> n = head.next; n != null ; n=n.next) {
            System.out.println(n.data);

        }
    }
}

public class Test053 {
    public static void main(String[] args) {

        LinkedList3<String> l =new LinkedList3();
        LinkedList3<Integer> l2 =new LinkedList3();
        l.add("가나").add("가나").add("가나").add("가나");
        l2.add(1).add(1).add(1).add(1).add(1);
        
        l.print();
        l2.print();

    }
}

```



### Test054.java 래퍼클래스

```java
/*
    Wrapper Class : 자료형 값을 감싸주는 가벼운 클래스.
    int -> Integer라는 클래스가 있음
    double -> Double 이라는 클래스가 있음

 */
public class Test054 {
    public static void main(String[] args) {
        Object ob = new Integer(100);
        Object ob2 = new Double(3.14);

        int i = ((Integer) ob).intValue();
        System.out.println( i );

        double j = ((Double)ob2).doubleValue();
        System.out.println( j );

    }
}

```

### Test055.java

```java

public class Test055 {
    public static void main(String[] args) {
        Integer i = 100; //1.4버젼까지는 에러가 났었다. 원칙적으로는 참조형변수가 자료값을 받는 게됨
        Object t = 200;
        System.out.println(i.getClass().getName());
        System.out.println(t.getClass().getName());

        int j = i ;
        System.out.println(j);

    }
}
/*
    Integer i = 100; 는 컴파일러가 Integer i = new Integer(100); 로 자동바꿈
    값을 래퍼클래스에 대입하는 코드는 자동으로 인스턴스 생성해서 값을 감싸준다.
    --이것을 Auto Boxing 이라고 한다.

    Object t = 200; Object 형 변수에 대해서도 AutoBoxing 은 동작한다.

    int j = i; 는 int j = i.intValue() 로 자동 변환하여 준다. ( Unboxing 이라 함)
 */

```



### Test056.java command pattern 매크로만들때 쓰는 것

```java
interface ICalc2 {
    public int execute( int i );
}
class AddCalc implements ICalc2 {
    private int data = 0;
    AddCalc( int j ) {
        data = j;
    }
    public int execute( int i ){
        return (i + data);
    }
}
class MinusCalc implements ICalc2{
    private int data = 0;
    MinusCalc( int j ) {
        data = j;
    }
    @Override
    public int execute(int i) {
        return i-data;
    }
}
public class Test056 {
    public static void main(String[] args) {
        ICalc2 i = new AddCalc(3);
        int r = 5;
        r = i.execute( r );
        System.out.println( r );

        ICalc2[] ls = new ICalc2[5];
        ls[0] = new AddCalc(2);
        ls[1] = new MinusCalc(6);
        ls[2] = new AddCalc(3);
        ls[3] = new MinusCalc(7);
        ls[4] = new AddCalc(5);

        int y = 10;
        for (int j = 0; j < ls.length; j++) {
            y = ls[j].execute(y);
            System.out.println(y);
        }
    }
}
/*
	일반적으로 자료값은 변수로, 동작은 함수로 만든다.

    동작을 하나의 인스턴스로 수행하게 하는 경우가 있다.
    - 이런 설계기법을 command pattern 이라고 한다.

    동작하나를 인스턴스로 만들어 저장해서 매크로 등등 이용
*/

```



```java
interface ICalc2 {
    public int execute( int i );
}
class AddCalc implements ICalc2 {
    private int data = 0;
    AddCalc( int j ) {
        data = j;
    }
    public int execute( int i ){
        return (i + data);
    }
}
/*
    빼기를 할 때는 **를 붙여서 프린트하라고 시키고 싶다.
    일시적으로 시키고 싶은 경우가 있더라.

    옛날 프로그래머들은 빈 인터페이스를 이럴 때 이용했다. 이건 고급기술

 */

interface   PrintStars{} //이게 어노테이션 조상뻘
class MinusCalc implements ICalc2, PrintStars{
    private int data = 0;
    MinusCalc( int j ) {
        data = j;
    }
    @Override
    public int execute(int i) {
        return i-data;
    }
}
public class Test056 {
    public static void main(String[] args) {
        ICalc2 i = new AddCalc(3);
        int r = 5;
        r = i.execute( r );
        System.out.println( r );

        ICalc2[] ls = new ICalc2[5];
        ls[0] = new AddCalc(2);
        ls[1] = new MinusCalc(6);
        ls[2] = new AddCalc(3);
        ls[3] = new AddCalc(7);
        ls[4] = new MinusCalc(5);

        int y = 10;
        for (int j = 0; j < ls.length; j++) {
            y = ls[j].execute(y);

            if( ls[j] instanceof PrintStars){
            System.out.print("**");  //추후 어노테이션으로 발전
            }
            System.out.println(y);
        }
    }
}
/*
	일반적으로 자료값은 변수로, 동작은 함수로 만든다.

    동작을 하나의 인스턴스로 수행하게 하는 경우가 있다.
    - 이런 설계기법을 command pattern 이라고 한다.

    동작하나를 인스턴스로 만들어 저장해서 매크로 등등 이용
*/

```



### Test057.java

```java
class Temp10 {
    int data = 0;

    // 아래코드의 t 와 this가 가리키는 대상은 같다.
    //      따라서  t.add(10) 은 10을 더한 후에 t로 바꿔 쓸 수 있어진다.
    //      StringBuffer 의 append 에서 볼 수 있다.

    Temp10 add(int i) {
        data = data + i;
        return this;
    }
}

public class Test057 {
    public static void main(String[] args) {
        Temp10 t = new Temp10();
        t.add(10).add(10).add(10).add(10).add(10).add(10).add(10);
        System.out.println(t.data);



    }
}

```



### Test058.java   StringBuffer

```java
public class Test058 {
    public static void main(String[] args) {
        StringBuffer sb =new StringBuffer("버퍼시작");
        sb.append("apple ");
        sb.append("banana ");
        String l = sb.toString();
        System.out.println(l);

    }
}
//"apple"+"banana" 는 컴파일러가 new StringBuffer().append("apple")
//  ,append("banana").toString();
/*
    아래 코드는 한 줄마다 new StringBuffer()가 동작해야 한ㄴ다.
    헌데 위의 main 의 예제는 하나의 StringBuffer 만 사용한다.
    : 메인 함수의 코드가 메모리 효율상 훨씬 좋다.

    String l = ""
    l=l+"*";
    l=l+"*";
    l=l+"*";
    ...
 */
//싱글 쓰레드에서는 StringBuilder 쓴다 동기화의 걱정이 없어서 동기화를 하면 느려진다. 

```

### Test059.java StringBuffer 성능차이

```java
public class Test059 {
    public static void main(String[] args) {
        long start1 =System.currentTimeMillis();
        String l = "";
        for (int i = 0; i < 100000; i++) {
            l=l+"apple";
        }
        System.out.println(l);
        long end1 =System.currentTimeMillis();

        long start2 =System.currentTimeMillis();
        StringBuffer l2 = new StringBuffer();
        for (int i = 0; i < 100000; i++) {
            l2.append("apple");
        }
        System.out.println(l2);
        long end2 =System.currentTimeMillis();
        System.out.println(end1-start1);
        System.out.println(end2-start2);
    }
}
/*
    java -verbosegc Test059
    메모리가 부족할 때 메모리를 비우고 확보하는 일을 모니터링 하게 된다.  -퍼포먼스 확인할때 메모리가 어디서 많이 샌다 하면 쓰면 좋음
 */

```



### Test060.java String 메소드

```java
public class Test060 {
    public static void main(String[] args) {
        String l = "HelloWorld";
        System.out.println(l.substring(2,5));  // llo
        //| H | e | l | l | o | W | o | r | l | d |
        //0   1   2   3   4   5   6   7   8   9   10

        // 문자열 안의 부분 문자열의 위치를 리턴 : 6
        System.out.println(l.indexOf("or"));

        // 없는 문자열을 찾을 때는 -1을 리턴한다.
        System.out.println(l.indexOf("xx"));

        //시작되는 단어를 비교한다 맞으면 true
        System.out.println(l.startsWith("Hell"));

        // 끝나는 단어를 비교한다.
        System.out.println(l.endsWith("ld"));

        // 자료형의 배열을 리턴해 준다.
        char[] ch = l.toCharArray();
        for (int i = 0; i < ch.length; i++) {
            System.out.println(ch[i]);

        }

    }
}

```



Test061.java

```java
class Temp11 {

    public static int indexOf(char[] targetWord, char[] objectWord) {
        int i = -1;
        int range = targetWord.length;
        int pointer = 0;
        int key = objectWord.length - 1;

        for (int j = 0; j < range; j++) {
            if (targetWord[j] ==objectWord[pointer]) {
                if(pointer==objectWord.length-1){
                    System.out.println("찾았다.");
                    i=j-pointer;
                    break;
                }
                pointer+=1;
            }else{
                j=j-pointer;
                pointer=0;
			
            }
        }
        return i;
    }
}

public class Test061 {
    public static void main(String[] args) {
        //String 의 indexOf 와 동일한 동작을 하도록 만들어 주세요.
        int idx = Temp11.indexOf("asdaaaad".toCharArray(), "ad".toCharArray());
        System.out.println(idx); // 6
    }
}

```



### Test061.java

```java
class Temp11 {

    public static int indexOf(char[] targetWord, char[] objectWord) {
        int i = -1;
        int range = targetWord.length;
        int pointer = 0;
        int key = objectWord.length - 1;

        for (int j = 0; j < range; j++) {
            if (targetWord[j] ==objectWord[pointer]) {
                if(pointer==objectWord.length-1){
                    System.out.println("찾았다.");
                    i=j-pointer;
                    break;
                }
                pointer+=1;
            }else{
                j=j-pointer;
                pointer=0;

            }
        }
        return i;
    }
}

public class Test061 {
    public static void main(String[] args) {

        //String 의 indexOf 와 동일한 동작을 하도록 만들어 주세요.
        int idx = Temp11.indexOf("HelloWorld".toCharArray(), "ld".toCharArray());
        System.out.println(idx); // 6
    }
}

```





# Day5. 자바기초

---

### Test062.java downcasting

```java
class A9{

}
class B9 extends A9{
    public void print(){
        System.out.println(100);
    }
}
public class Test062 {
    public static void main(String[] args) {
        A9 t = new B9();
//        t.print();    조상클래스에 print가 없어서 호출불가

        B9 t2 = (B9)t; //down casting
        t2.print();

        // 참조형변수 instanceof 클래스명 (B)t 이것이 가능하면 true/ 아니면 false
        A9 t3 = new A9();
        //t 가 가리키는 인스턴스를 감싸는 B 인스턴스 영역이 존재해야만 가능
        if( t3 instanceof B9){
            B9 t4 = (B9)t3;  // 존재하지 않는 인스턴스를 가리키기 때문에 에러가 난다.java.lang.ClassCastException: A9 cannot be cast to B9
            t4.print();
        }
    }
}

```

### Test063.java double의 오차


```java

public class Test063 {
    public static void main(String[] args) {
        boolean i = true;
        boolean j = false;

        System.out.println(10<3);
        System.out.println(10/3);
        System.out.println(10%3);
        System.out.println(10.0/3); //3.3333333333333335 보면 5가 생기는데 3.3333.... 의 결과와 가장 유사한 값으로 만든것이다.  그렇기 때문에 이 작은 값으로 오차가 날 수 있다는것을 기억하자

        System.out.println(3.3333333333333333 *3 ==10.0); //true 가 된다.
        int k= 0;
        boolean k2=true;
        while (k2){
            k2=3.3333333333333330 *3 ==10.0;
        }

        System.out.println(3.3333333333333330 *3 ==10.0); //true 가 된다. 이렇게  예상하지 못한 결과가 나올 수 있다.
        // 비교연산은 boolean 값을 리턴 : ==, != , > , < , >= , <=
        // 거의 모든 연산은 같은 자료형 끼리 가능 : int / int = int, int + int = int, int % int = int 그리고 대부분 결과도 같음
    }
}
// C 는 정수값 0 은 false , 0 이 아닌 모든 정수는 true
// if( 100 )

```

### Test064.java

```java
import temp.Test064A; //다른 패키지 안에 클래스를 사용하고 싶으면

public class Test064 {
    public static void main(String[] args) {
        Test064A t =null;
    }
}
/*
    다른 패키지의 클래스는 반드시 명시해야 사용할 수 있다. (import)
	javac -classpath C:\temp\ Test064.java
	java -classpath .;C:\ Test064		 실행할 때 양쪽패스를 다 넣어줘야한다. 앞에 .은 현재디렉토리의 Test064.class 를 찾고 ;뒤에 C:\에 있는 것을 찾는데 temp.Test064A로 되어 있으니 두개를 합쳐 경로가 C:\temp\Test064A.class가 된다.
    java -classpath new;C:\ Test064 cmd는 .고 .\new 위치에 Test064클래스가 있는경우
    만일 그래도 클래스를 못 찾으면, 클래스의 위치를 지정해 주어야 한다.
 */




```

### Test064A

```java
package temp;
public class Test064A {
    public int print(){return 200;}
    public int print2( int i ){return 300 * i;}
    public static int print3(){
        return 100;
    }
}
//
/*
    패키지가 지정된 클래스 컴파일 javac -d [폴더] Test064A.java
    대상폴더 아래에 이름으로 폴더 생기고 , 그 아래에 class 파일이 들어간다.

    -패키지를 지정 안하면 Unnamed 패키지에 소속된다. 이건 사용시 제약이 많다.

    패키지는 클래스의 묶음 . 파일 맨 위에 지정 .
        이 파일안에 선언한 모든 클래스는 지정된 패키지에 속한다.

    javac -d . Test064A.java
 */

```



### Test065.java
```java
import temp.Test065A;
public class Test065 {
	public static void main(String[] args){
		Test065A t= new Test065A();
		System.out.println(t.i);
	}
}
// -classpath 옵션을 안주면 -classpath . 이 자동으로 붙는다.
// Test065A 의 멤버 변수 i 가 접근 되는지 살펴본다 : protected , friendly
```





#### Test065A.java
```java
package temp;
public class Test065A {
    public int i =100;
	public int print(){return 200; }
	public int print2(int i){return 300; }
	
	public int print2(){return 100; }



}
```
### Test066.java Class .forName이용 인스턴스생성
```java
public class Test066{
	public static void main(String[] args) throws Exception{
		
		// 클래스를 찾아내서 해당 클래스를 강제로 메모리에 로딩시킨다.
		//		로딩시키는 클래스의 static initailizer 가 동작한다.
		//Class.forName("temp.Test066A");
		Class<?> cls = Class.forName("temp.Test066A"); 
		
		/*Class : 로딩된 클래스의 관리자 역할을 한다.
			cls.newInstance() : cls 가 관리하는 temp.Test066A 의 인스턴스를 생성한다.
			
			obj.getClass().getName(): obj 가 가리키는 인스턴스를 생성시킨 클래스 명
			: import 없이도 다른패키지의 클래스의 인스턴스를 생성할 수 있다.
		*/
		Object obj = cls.newInstance();
		
		System.out.println( obj.getClass().getName() );
	}
}
//javac Test066.java
//java -classpath .;C:\A\ Test066  줘야 에러 안남  ;기준 좌우 test066위치 다른 임포트쪽?
// javac -d C:\A\ Test066A.java
//Test066A.class 위치는 C:\A\temp\Test066A.class
```

#### Test066A.java
```java
package temp;
public class Test066A {
	
	//static initializer 라 한다. 클래스가 로딩되는 시점에 호출됩니다.
	static {  
		System.out.println( "Test066A loaded" );
	
	}
	public int i =100;
	public int print(){return 200; }
	public int print2(int i){return 300; }
	
	public int print2(){return 100; }

}

// c:\A\ 아래에 컴파일 하자. javac -d C:\A\ Test066A.java
```

#### Test066_2.java
```java
import java.lang.reflect.Method;
public class Test066_2{
    public static void main(String[] args) throws Exception{


        Class<?> cls = Class.forName("temp.Test066A");
        Object obj = cls.newInstance();
    
    	//Method가 자바에서의 함수포인터
        Method[] mtds =  cls.getMethods();
        for (int i = 0; i < mtds.length; i++) {
            System.out.println(mtds[i]);
        }
    }
}
//javac Test066.java
//java -classpath .;C:\A\ Test066  줘야 에러 안남
// javac -d C:\A\ Test066A.java
//Test066A.class 위치는 C:\A\temp\Test066A.class
```

#### Test066_3.java
```java
import java.lang.reflect.Method;
public class Test066_3{
    public static void main(String[] args) throws Exception{


        Class<?> cls = Class.forName("temp.Test066A");
        Object obj = cls.newInstance();
        /*
            Method 는 c의 함수포인터의 역할을 한다.
            cls.getMethods() : 모든 멤버함수의 포인터를 넘긴다.
            cls.getMethod(...) : 단 하나의 멤버함수의 포인터를 넘긴다.
                ... 에는 함수이름 , 매개변수의 형태를 명시한다.
         */
//        Method mtd =  cls.getMethod(" print ");
        Method mtd =  cls.getMethod("print2",int.class); // print2는 메소드 이름 뒤에 int.class는 매개변수
        System.out.println( mtd); //자동으로 toString();
		
		//mtd.invoke(obj,20); obj 돌릴 인스턴스  20은 매개변수   스태틱의 경우 cls를 넣어주어야함
		Object r = mtd.invoke(obj, 20);   //오토박싱함 리턴타입이 Object고   
        System.out.println(((Integer)r).intValue() );
    }
}
//javac Test066.java
//java -classpath .;C:\A\ Test066  줘야 에러 안남
// javac -d C:\A\ Test066A.java
//Test066A.class 위치는 C:\A\temp\Test066A.class
```



### Test067.java 어노테이션, 리플렉션
```java
package temp;

public class Test067{
    
	@PrintStars
	public int print(){return 100;}

}

//javac -d C:\A\ -classpath C:\A\ Test067.java   -d는 저장 위치  -classpath는 다른 클래스들 위치
```

#### PrintStars.java 
```java
package temp;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;


@Retention(RetentionPolicy.RUNTIME)
public @interface PrintStars { //

}

//javac -d C:\A\ PrintStar.java
```

#### Test067_2.java

```java
import java.lang.reflect.Method;
import temp.PrintStars;
import java.lang.annotation.Annotation;
public class Test067_2{
    public static void main(String[] args) throws Exception{
		Class<?> cls = Class.forName("temp.Test067");
		Object obj = cls.newInstance();
		Method mtd = cls.getMethod("print");
		System.out.println(mtd);
		
		Annotation anot = mtd.getAnnotation(PrintStars.class); //이제 가져다 쓰니 임포트 필요 
		Object r = mtd.invoke(obj);
		if(anot != null){
			System.out.print("**");
		}
		System.out.println(((Integer)r).intValue());
		
		
	}
}
// javac Test067_2.java
// java -classpath C:\A\;. Test067_2      // -classpath는 필요한 만큼 패스를 찍어준다 구분자 ;
```

리플렉션 부탁하는용도로 class가 씀 호출당하는 쪽이 호출하는쪽에 요청



## 자바 컬렉션즈Java.util.

자주쓴다고함

### Test068.java  java.util. List

#### ArrayList 이용

```java



import java.util.*;
/*
	ArrayList 속도가 빠르다. 내부적으로 배열을 이용한다.
	-배열을 써서 단순히 쌓는 속도는 빠른데, 중간 삭제시에는 비효율적이다.
	꽉차면 2배로 늘림 소라게가 고동을 옮기 듯이 단 이때 오버헤드 발생
*/
public class Test068{
    public static void main(String[] args) throws Exception{
		List<String> l = new ArrayList<String>();
		l.add("apple");
		l.add("banana");
		l.add("orange");
		l.add("kiwi");
		

		// 향상ㄷ괸 for 문장
		for(String t : l){
			System.out.println(t);
		}
	}
}

```



#### LinkedList이용

```java
import java.util.*;
/*
	ArrayList 속도가 빠르다. 내부적으로 배열을 이용한다.
	-배열을 써서 단순히 쌓는 속도는 빠른데, 중간 삭제시에는 비효율적이다.
	꽉차면 2배로 늘림 소라게가 고동을 옮기 듯이 단 이때 오버헤드 발생
	
	LinkedList는 Node 를 이용하기에 단순하게 쌓는 속도는 느리다.
		중간에 추가 삭제가 빈번한 경우에는 용이하다.
	
	둘다 사용가능한 이유는 둘다 List를 상속한다.
	List를 상속받은 클래스는 특징이 존재한다.
	-중복되는 걸 허용한다. 검색시에 들어간 순서대로 나온다. (수너대로 보관한다.)
*/
public class Test068{
    public static void main(String[] args) throws Exception{
		List<String> l = new LinkedList<String>();
		l.add("apple");
		l.add("banana");
		l.add("orange");
		l.add("kiwi");
		l.add("apple");
		
		// 향상ㄷ괸 for 문장
		for(String t : l){
			System.out.println(t);
		}
	}
}
```



### Test069.java java  java.util.  Set

#### TreeSet

```java
import java.util.*;
/*
	Set 인터페이스를 상속받은 것: TreeSet, HashSet
	공통특징 : 순서개념이 없다. 중복보관은 허용하지 않는다. 검색속도가 List 보다 월등
	
	TreeSet : 트리를 이용하여 보관 , HashSet 는 헤쉬 알고리즘으로 기억장소를 결정
*/
public class Test069{
    public static void main(String[] args) throws Exception{
		Set<String> ls = new TreeSet<String>();
		ls.add("banana");
		ls.add("apple");
		ls.add("orange");
		ls.add("kiwi");
		ls.add("apple");
		
		for( String l : ls){
		System.out.println(l);
	}
}
}
```

#### HashSet
```java
import java.util.*;
/*
	Set 인터페이스를 상속받은 것: TreeSet, HashSet
	공통특징 : 순서개념이 없다. 중복보관은 허용하지 않는다. 검색속도가 List 보다 월등
	
	TreeSet : 트리를 이용하여 보관 , HashSet 는 헤쉬 알고리즘으로 기억장소를 결정
*/
public class Test069{
    public static void main(String[] args) throws Exception{
		Set<String> ls = new HashSet<String>();
		ls.add("banana");
		ls.add("apple");
		ls.add("orange");
		ls.add("kiwi");
		ls.add("apple");
		
		for( String l : ls){
		System.out.println(l);
	}
}
}

```

#### Iterator

```java
import java.util.*;
/*
	Set 인터페이스를 상속받은 것: TreeSet, HashSet
	공통특징 : 순서개념이 없다. 중복보관은 허용하지 않는다. 검색속도가 List 보다 월등
	
	TreeSet : 트리를 이용하여 보관 , HashSet 는 헤쉬 알고리즘으로 기억장소를 결정
*/
public class Test069{
    public static void main(String[] args) throws Exception{
		Set<String> ls = new HashSet<String>();
		ls.add("banana");
		ls.add("apple");
		ls.add("orange");
		ls.add("kiwi");
		ls.add("apple");
		
		// java의 표준 검색방법이 Iterator
		Iterator<String> it = ls.iterator();
		while(it.hasNext() ) {
			String l = it.next();
			if(l.indexOf("an") != -1){
				it.remove();
			}
		}
			System.out.println(ls);  
	}
}
```



### Test070.java  java.util Map
```java
import java.util.*;
/*
	map은 순서 개념 없이 key=value 형태의 마치 사전과 같은 형태로 저장합니다.
	put 함수로 저장,  get 함수로 key 에 해당하는 value를 뽑아낸다.

	List , set , Map 형태로 뭔가를 저장하는 형태를 흔히 Collection 이라고 한다.
	List 순서 있음 중복 허용 , set 순서없음 중복허용하지 않음 , Map 순서없음  중복허용하지 않음 쌍으로 저장
	*/
public class Test070{
    public static void main(String[] args) throws Exception{
        Map<String,String> map = new Hashtable<String,String>();
        map.put("apple","사과");
        map.put("banana","바나나");
        map.put("orange","오렌지");
        map.put("kiwi","키위");
        map.put("apple","사과2"); //전에 있던 값을 덮어씌움

        System.out.println(map);
        String value = map.get("kiwi");
        System.out.println(value);

        // Iterator 는 표준 검색방법이다. KeySet() 은 key 값만의 Set 을 생성한다.
        Set<String> keys = map.keySet();
        Iterator<String> it = keys.iterator();
        while (it.hasNext()){
            String l = it.next();
            String v = map.get(l);
            System.out.println(l + " " + v);
        }

        System.out.println(map.toString());
    }
}
```



### Test071.java

```java
/*
    Math.random(): 0 에서 1 사이의 소수값을 랜덤하게 출력한다. util 아래도 있다고 함 랜덤
    곱해서 캐스팅 하는 형태로 해서 정수를 발생시킬 수 있다.
 */

public class Test071 {
    public static void main(String[] args) {
        for (int i = 0; i < 20; i++) {
            double d = Math.random();
            System.out.println((int)(d*100));
        }
    }
}

```



### Test072.java 과제1





## Exception

### Test074.java RuntimeException

```java
class TempExceotion extends RuntimeException{}
/*
    java 에서 각종 에러는 class로 구현된다. extends Exception , extends RuntimeException

    코드 수행시 에러가 발생되면 해당 예외 클래스의 인스턴스를 throw 한다.
    발생된 예외를 적절하게 처리하지 못하면 프로그램은 종료한다.

    "예외는 함수 수행시에 발생되고 , 함수에 그 사실을 명시한다.
 */
public class Test074 {
    public static void main(String[] args) {
        int i = 0;
        if(i==0){
            throw new TempExceotion(); //예외 개념
        }
        System.out.println(0);
    }
}

```

### Test075.java Exception

```java
//연료 고갈이라는 에러를 클래스로 명시함
class FuelExceotion extends Exception{
    public void solve() {

    }
}
/*
    Exception 이 깐깐하다. : 컴파일이 안된다 ...
    -함수에서 에러가 발생할 수 있다면 그 사실을 선언부에 명시해야 컴파일 된다. runtimeException은 싱행가능

 */
public class Test075 {
    public void carDrive( int fuel) throws FuelExceotion {
        if(fuel == 0){
//            throw new 배째기(); // 이 있고 Exception의 경우 함수 매개변수 오른쪽에 throws 배쨰기 해야함
            throw new FuelExceotion();
        }
        System.out.println("GOGO!!");
    }
    public static void main(String[] args) {
        Test075 t =new Test075();
        try{
            t.carDrive(100);
        }catch (FuelExceotion e){
            e.solve();//e로 접근하여 해결도 가능 
            System.out.println("견인차를 불러라");
        }
    }
}
/*
    throws FuelException 으로 선언된 험슈룰 호출할 때는
    반드시 에러가 발생할 수 있는 영역으로 try{...} 로 감싸준다.

    try 애는 반드시 1개 이상의 catch 가 있어야 한다.
    에러가 발생되며 에러 인스턴스를 throw 한다.

    catch( FuelException e)에 있는 e 변수가 발생된 에러 인스턴스르 가리킬 수 있으면
    catch 에 딸린 {...} 영역이 동작한다.
     ... 에는 에러를 수습할 수 있는 코드가 들어가는 것이 바람직하다.

    catch( Exception e) 을 써도 되는? ok
 */

```



